<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
    <title>데이터 정의</title>

    <para>
        이 장에서는 데이터를 보관할 데이터베이스 구조를 만드는 방법을 다룹니다.
        관계형 데이터베이스에서는 원시 데이터가 테이블에 저장되므로, 이 장의 대부분은
        테이블을 생성하고 수정하는 방법과 테이블에 저장되는 데이터를 제어하는 데 사용할 수 있는
        기능들을 설명합니다. 이어서 테이블을 스키마로 구성하는 방법과
        테이블에 권한을 할당하는 방법에 대해 설명합니다. 마지막으로 상속, 테이블 파티셔닝,
        뷰, 함수, 트리거와 같이 데이터 저장에 영향을 미치는 다른 기능들을 간단히 살펴보겠습니다.
    </para>

    <sect1 id="ddl-basics">
        <title>테이블 기초</title>

        <indexterm zone="ddl-basics">
            <primary>table</primary>
        </indexterm>

        <indexterm>
            <primary>row</primary>
        </indexterm>

        <indexterm>
            <primary>column</primary>
        </indexterm>

        <para> 관계형 데이터베이스의 테이블은 종이 위의 표와 매우 비슷합니다. 행과 열로 구성됩니다. 열의 개수와 순서는 고정되어 있으며, 각 열에는 이름이 있습니다.
            행의 수는 가변적이며 주어진 시점에 저장된 데이터의 양을 반영합니다. SQL은 테이블의 행 순서에 대해 어떠한 보장도 하지 않습니다. 테이블을 읽을 때
            명시적으로 정렬을 요청하지 않는 한 행은 지정되지 않은 순서로 나타납니다. 이는 <xref linkend="queries" />에서 다룹니다. 또한 SQL은
            행에 고유 식별자를 할당하지 않으므로, 테이블에 완전히 동일한 행이 여러 개 있을 수 있습니다. 이는 SQL의 기반이 되는 수학적 모델의 결과이지만 일반적으로
            바람직하지 않습니다. 이 장의 뒷부분에서 이 문제를 다루는 방법을 살펴보겠습니다. </para>

        <para>
            각 열에는 데이터 타입이 있습니다. 데이터 타입은 열에 할당할 수 있는 가능한 값의
            집합을 제한하고, 열에 저장된 데이터에 의미를 부여하여 계산에 사용할 수 있게 합니다.
            예를 들어, 숫자 타입으로 선언된 열은 임의의 텍스트 문자열을 허용하지 않으며,
            이러한 열에 저장된 데이터는 수학적 계산에 사용할 수 있습니다. 반면에 문자열
            타입으로 선언된 열은 거의 모든 종류의 데이터를 허용하지만 수학적 계산에는
            적합하지 않습니다. 다만 문자열 연결과 같은 다른 연산은 가능합니다.
        </para>

        <para>
            <productname>PostgreSQL</productname>은 많은 응용 프로그램에 적합한 상당한 양의 내장 데이터 타입을 포함하고 있습니다. 사용자는
            자신만의 데이터 타입을 정의할 수도 있습니다. 대부분의 내장 데이터 타입은 명확한 이름과 의미를 가지고 있으므로, 자세한 설명은 <xref
                linkend="datatype" />로 미루겠습니다. 자주 사용되는 데이터 타입에는 정수를 위한 <type>integer</type>, 소수점이 있을
            수 있는 숫자를 위한 <type>numeric</type>, 문자열을 위한 <type>text</type>, 날짜를 위한 <type>date</type>,
            하루 중 시간을 위한 <type>time</type>, 날짜와 시간을 모두 포함하는 값을 위한 <type>timestamp</type>가 있습니다. </para>

        <indexterm>
            <primary>table</primary>
            <secondary>creating</secondary>
        </indexterm>

        <para> 테이블을 생성하려면 적절하게 명명된 <xref linkend="sql-createtable" /> 명령을 사용합니다. 이 명령에서는 최소한 새 테이블의
            이름, 열의 이름과 각 열의 데이터 타입을 지정해야 합니다. 예를 들면: <programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting> 이는 <literal>
            my_first_table</literal>이라는 이름의 테이블을 두 개의 열로 생성합니다. 첫 번째 열의 이름은 <literal>first_column</literal>이고
            데이터 타입은 <type>text</type>입니다. 두 번째 열의 이름은 <literal>second_column</literal>이고 타입은 <type>
            integer</type>입니다. 테이블과 열 이름은 <xref linkend="sql-syntax-identifiers" />에서 설명한 식별자 구문을
            따릅니다. 타입 이름도 일반적으로 식별자이지만 예외가 있습니다. 열 목록은 쉼표로 구분되고 괄호로 둘러싸여 있다는 점에 유의하세요. </para>

        <para> 이전 예제는 매우 인위적이었습니다. 일반적으로는 테이블과 컬럼에 저장할 데이터의 종류를 나타내는 이름을 부여할 것입니다. 그래서 좀 더 현실적인 예제를
            살펴보겠습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting> (<type>numeric</type> 타입은 화폐 금액에서 일반적으로 볼 수
            있는 소수 부분을 저장할 수 있습니다.) </para>

        <tip>
            <para>
                서로 연관된 많은 테이블을 생성할 때는 테이블과 컬럼에 대해
                일관된 명명 패턴을 선택하는 것이 현명합니다.
                예를 들어, 테이블 이름에 단수 명사를 사용할지 복수 명사를 사용할지에 대한
                선택이 있는데, 이는 각각 다른 이론가들이 선호하는 방식입니다.
            </para>
        </tip>

        <para>
            테이블이 포함할 수 있는 컬럼 수에는 제한이 있습니다.
            컬럼 타입에 따라 250에서 1600 사이입니다.
            하지만, 이에 근접한 수의 컬럼으로 테이블을 정의하는 것은
            매우 비정상적이며 종종 의심스러운 설계가 됩니다.
        </para>

        <indexterm>
            <primary>table</primary>
            <secondary>removing</secondary>
        </indexterm>

        <para> 더 이상 테이블이 필요하지 않다면, <xref linkend="sql-droptable" /> 명령을 사용하여 제거할 수 있습니다. 예를 들면: <programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
            존재하지 않는 테이블을 삭제하려고 하면 오류가 발생합니다. 그럼에도 불구하고, SQL 스크립트 파일에서는 테이블 존재 여부와 관계없이 스크립트가 작동하도록
            오류 메시지를 무시하고 각 테이블을 생성하기 전에 무조건 삭제를 시도하는 것이 일반적입니다. 원한다면, <literal>DROP TABLE IF EXISTS</literal>
            변형을 사용하여 오류 메시지를 피할 수 있지만, 이는 표준 SQL이 아닙니다. </para>

        <para> 이미 존재하는 테이블을 수정해야 한다면, 이 장의 뒷부분에 있는 <xref linkend="ddl-alter" />를 참조하십시오. </para>

        <para> 지금까지 논의한 도구들로 완전히 기능하는 테이블을 생성할 수 있습니다. 이 장의 나머지 부분은 데이터 무결성, 보안 또는 편의성을 보장하기 위해 테이블
            정의에 기능을 추가하는 것에 관한 것입니다. 지금 바로 테이블에 데이터를 채우고 싶다면 <xref linkend="dml" />로 건너뛰고 이 장의 나머지
            부분은 나중에 읽으셔도 됩니다. </para>
    </sect1>

    <sect1 id="ddl-default">
        <title>기본값</title>

        <indexterm zone="ddl-default">
            <primary>default value</primary>
        </indexterm>

        <para> 열에는 기본값을 할당할 수 있습니다. 새로운 행이 생성될 때 일부 열에 값이 지정되지 않으면, 해당 열들은 각각의 기본값으로 채워집니다. 데이터 조작
            명령은 그 값이 무엇인지 알 필요 없이 열을 기본값으로 설정하도록 명시적으로 요청할 수도 있습니다. 참고로, 데이터 조작 명령에 대한 자세한 내용은 <xref
                linkend="dml" />에 있습니다. </para>

        <para>
            <indexterm>
                <primary>null value</primary>
                <secondary>default value</secondary>
            </indexterm> 기본값이 명시적으로 선언되지 않으면,
            기본값은 널(null) 값입니다. 널 값은 알 수 없는 데이터를 나타내는 것으로 간주될 수 있으므로 이는 대개 타당합니다. </para>

        <para> 테이블 정의에서 기본값은 열 데이터 타입 뒤에 나열됩니다. 예를 들면: <programlisting>
CREATE TABLE products (
   product_no integer,
   name text,
   price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
        </para>

        <para> 기본값은 표현식이 될 수 있으며, 이는 기본값이 테이블이 생성될 때가 아니라 삽입될 때마다 평가됩니다. 흔한 예시로 <type>timestamp</type>
            열이 <literal>CURRENT_TIMESTAMP</literal>를 기본값으로 가져 행이 삽입되는 시간으로 설정되도록 하는 것이 있습니다. 또 다른 흔한
            예시는 각 행에 대해 <quote>일련번호</quote>를 생성하는 것입니다. <productname>PostgreSQL</productname> 에서는
            이것을 일반적으로 다음과 같이 수행합니다: <programlisting>
CREATE TABLE products (
   product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
   ...
);
</programlisting>
            여기서 <literal>nextval()</literal> 함수는 <firstterm>시퀀스 객체</firstterm>로부터 연속된 값을 제공합니다(참조 <xref
                linkend="functions-sequence" />). 이 방식은 매우 일반적이어서 이를 위한 특별한 축약형이 있습니다: <programlisting>
CREATE TABLE products (
   product_no <emphasis>SERIAL</emphasis>,
   ...
);
</programlisting>
  <literal>
            SERIAL</literal> 축약형에 대해서는 <xref linkend="datatype-serial" />에서 자세히 설명합니다. </para>
    </sect1>

    <sect1 id="ddl-identity-columns">
        <title>Identity 컬럼</title>

        <indexterm zone="ddl-identity-columns">
            <primary>identity column</primary>
        </indexterm>

        <para>
            Identity 컬럼은 내부 시퀀스로부터 자동으로 생성되는 특별한 컬럼입니다. 키 값을 생성하는 데 사용될 수 있습니다.
        </para>

        <para> Identity 컬럼을 생성하려면 <command>CREATE TABLE</command>에서 <literal>GENERATED ... AS
            IDENTITY</literal> 구문을 사용하십시오. 예를 들면: <programlisting>
CREATE TABLE people (
    id bigint <emphasis>GENERATED ALWAYS AS IDENTITY</emphasis>,
    ...,
);
</programlisting>
            또는 다음과 같이 사용할 수 있습니다: <programlisting>
CREATE TABLE people (
    id bigint <emphasis>GENERATED BY DEFAULT AS IDENTITY</emphasis>,
    ...,
);
</programlisting> 자세한
            내용은 <xref linkend="sql-createtable" />를 참조하십시오. </para>

        <para> Identity 컬럼이 있는 테이블에 <command>INSERT</command> 명령을 실행할 때 Identity 컬럼에 대한 값이 명시적으로
            지정되지 않은 경우, 내부 시퀀스에 의해 생성된 값이 삽입됩니다. 예를 들어, 위의 정의와 추가적인 적절한 컬럼이 있다고 가정할 때, 다음과 같이 작성하면: <programlisting>
INSERT INTO people (name, address) VALUES ('A', 'foo');
INSERT INTO people (name, address) VALUES ('B', 'bar');
</programlisting>
            id 컬럼에 대해 1부터 시작하는 값이 생성되어 다음과 같은 테이블 데이터가 됩니다: <screen>
 id | name | address
----+------+---------
  1 | A    | foo
  2 | B    | bar
</screen> 또는 시퀀스 생성 값을 명시적으로
            요청하기 위해 값 대신 <literal>DEFAULT</literal> 키워드를 지정할 수 있습니다: <programlisting>
INSERT INTO people (id, name, address) VALUES (<emphasis>DEFAULT</emphasis>, 'C', 'baz');
</programlisting>
            마찬가지로 <command>UPDATE</command> 명령에서도 <literal>DEFAULT</literal> 키워드를 사용할 수 있습니다. </para>

        <para> 따라서 많은 면에서 Identity 컬럼은 기본값(<literal>DEFAULT</literal>)이 있는 컬럼처럼 동작합니다. </para>

        <para> 컬럼 정의을 정의할 때, <literal>ALWAYS</literal>와 <literal>BY DEFAULT</literal> 구문은 <command>
            INSERT</command>와 <command>UPDATE</command> 명령에서 사용자가 명시적으로 지정한 값을 어떻게 처리할지 결정합니다. <command>
            INSERT</command> 명령에서 <literal>ALWAYS</literal>가 선택된 경우, 사용자가 지정한 값은 <command>INSERT</command>
            문이 <literal>OVERRIDING SYSTEM VALUE</literal>를 지정한 경우에만 허용됩니다. <literal>BY DEFAULT</literal>가
            선택된 경우, 사용자가 지정한 값이 우선합니다. 따라서 <literal>BY DEFAULT</literal>를 사용하면 기본값과 더 유사한 동작을 보이며,
            명시적 값으로 기본값을 덮어쓸 수 있습니다. 반면 <literal>ALWAYS</literal>는 실수로 명시적 값을 삽입하는 것을 방지하는 더 많은 보호를
            제공합니다. </para>

        <para> Identity 컬럼의 데이터 타입은 시퀀스가 지원하는 데이터 타입 중 하나여야 합니다. (<xref linkend="sql-createsequence" />
            참조) 관련 시퀀스의 속성은 Identity 컬럼을 생성할 때 지정하거나 (<xref linkend="sql-createtable" /> 참조) 나중에 변경할
            수 있습니다 (<xref linkend="sql-altertable" /> 참조). </para>

        <para> Identity 컬럼은 자동으로 <literal>NOT NULL</literal>로 표시됩니다. 그러나 Identity 컬럼은 고유성을 보장하지
            않습니다. 시퀀스는 일반적으로 고유한 값을 반환하지만, 시퀀스가 재설정되거나 위에서 설명한 대로 Identity 컬럼에 수동으로 값이 삽입될 수 있습니다.
            고유성은 <literal>PRIMARY KEY</literal> 또는 <literal>UNIQUE</literal> 제약 조건을 사용하여 강제해야 합니다. </para>

        <para> 테이블 상속 계층에서 자식 테이블의 Identity 컬럼과 그 속성은 부모 테이블의 것과 독립적입니다. 자식 테이블은 부모로부터 Identity 컬럼이나
            그 속성을 자동으로 상속하지 않습니다. <command>INSERT</command> 또는 <command>UPDATE</command> 중에 문에서 명명된
            테이블에서 해당 컬럼이 Identity 컬럼인 경우 해당 컬럼은 Identity 컬럼으로 취급되며, 해당 Identity 속성이 적용됩니다. </para>

        <para>
            파티션은 파티션된 테이블로부터 Identity 컬럼을 상속받습니다. 파티션은 자체 Identity 컬럼을 가질 수 없습니다. 주어진 Identity 컬럼의
            속성은 파티션 계층의 모든 파티션에서 일관됩니다.
        </para>
    </sect1>

    <sect1 id="ddl-generated-columns">
        <title>생성된 컬럼</title>

        <indexterm zone="ddl-generated-columns">
            <primary>generated column</primary>
        </indexterm>

        <para>
            생성된 컬럼은 항상 다른 컬럼들로부터 계산되는 특별한 컬럼입니다.
            따라서 테이블에 대한 뷰와 같은 역할을 컬럼에 대해 수행합니다.
            생성된 컬럼에는 저장된(stored) 컬럼과 가상(virtual) 컬럼의 두 종류가 있습니다.
            저장된 생성 컬럼은 작성될 때(삽입 또는 갱신) 계산되며 일반 컬럼처럼 저장 공간을 차지합니다.
            가상 생성 컬럼은 저장 공간을 차지하지 않으며 읽을 때 계산됩니다.
            따라서 가상 생성 컬럼은 뷰와 비슷하고 저장된 생성 컬럼은 구체화된 뷰와 비슷합니다
            (항상 자동으로 갱신된다는 점만 다릅니다).
        </para>

        <para> 생성된 컬럼을 만들려면 <command>CREATE TABLE</command>에서 <literal>GENERATED ALWAYS AS</literal>
            구문을 사용하십시오. 예를 들면: <programlisting>
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric <emphasis>GENERATED ALWAYS AS (height_cm / 2.54)</emphasis>
);
</programlisting> 생성된
            컬럼은 기본적으로 가상 유형입니다. <literal>VIRTUAL</literal> 또는 <literal>STORED</literal> 키워드를 사용하여
            명시적으로 선택할 수 있습니다. 자세한 내용은 <xref linkend="sql-createtable" />를 참조하십시오. </para>

        <para> 생성된 컬럼은 직접 쓰기가 불가능합니다. <command>INSERT</command> 또는 <command>UPDATE</command> 명령에서
            생성된 컬럼에 대한 값을 지정할 수 없지만, <literal>DEFAULT</literal> 키워드는 지정할 수 있습니다. </para>

        <para> 기본값이 있는 컬럼과 생성된 컬럼의 차이점을 고려해보십시오. 컬럼 기본값은 다른 값이 제공되지 않았을 때 행이 처음 삽입될 때 한 번 평가됩니다. 생성된
            컬럼은 행이 변경될 때마다 갱신되며 재정의할 수 없습니다. 컬럼 기본값은 테이블의 다른 컬럼을 참조할 수 없습니다. 생성 표현식은 일반적으로 이를 수행합니다.
            컬럼 기본값은 <literal>random()</literal>이나 현재 시간을 참조하는 함수와 같은 휘발성 함수를 사용할 수 있습니다. 이는 생성된
            컬럼에서는 허용되지 않습니다. </para>

        <para> 생성된 컬럼과 생성된 컬럼을 포함하는 테이블의 정의에는 여러 제약 사항이 적용됩니다: <itemizedlist>
                <listitem>
                    <para>
                        생성 표현식은 불변 함수만 사용할 수 있으며 하위 쿼리를 사용하거나
                        현재 행 이외의 어떤 것도 참조할 수 없습니다.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        생성 표현식은 다른 생성된 컬럼을 참조할 수 없습니다.
                    </para>
                </listitem>
                <listitem>
                    <para> 생성 표현식은 <varname>tableoid</varname>를 제외한 시스템 컬럼을 참조할 수 없습니다. </para>
                </listitem>
                <listitem>
                    <para>
                        생성된 컬럼은 컬럼 기본값이나 identity 정의를 가질 수 없습니다.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        생성된 컬럼은 파티션 키의 일부가 될 수 없습니다.
                    </para>
                </listitem>
                <listitem>
                    <para> 외부 테이블은 생성된 컬럼을 가질 수 있습니다. 자세한 내용은 <xref linkend="sql-createforeigntable" />를
            참조하십시오. </para>
                </listitem>
                <listitem>
                    <para>상속과 파티셔닝에 대해:</para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                부모 컬럼이 생성된 컬럼인 경우, 자식 컬럼도 같은 종류(저장 또는 가상)의
                                생성된 컬럼이어야 합니다. 하지만 자식 컬럼은 다른 생성 표현식을 가질 수 있습니다.
                            </para>

                            <para>
                                저장된 생성 컬럼의 경우, 행의 삽입이나 갱신 중에 실제로 적용되는
                                생성 표현식은 그 행이 물리적으로 있는 테이블과 연관된 것입니다.
                                (이는 컬럼 기본값의 동작과는 다릅니다: 기본값의 경우, 쿼리에서
                                명명된 테이블과 연관된 기본값이 적용됩니다.) 가상 생성 컬럼의 경우,
                                테이블을 읽을 때 쿼리에서 명명된 테이블의 생성 표현식이 적용됩니다.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                부모 컬럼이 생성된 컬럼이 아닌 경우, 자식 컬럼도 생성된 컬럼이
                                되어서는 안 됩니다.
                            </para>
                        </listitem>
                        <listitem>
                            <para> 상속된 테이블의 경우, <command>CREATE TABLE ... INHERITS</command>에서 <literal>
            GENERATED</literal> 구문 없이 자식 컬럼 정의를 작성하면, 그 <literal>GENERATED</literal> 구문은 자동으로 부모로부터
            복사됩니다. <command>ALTER TABLE ... INHERIT</command>는 부모와 자식 컬럼이 생성 상태에 대해 이미 일치할 것을 요구하지만,
            생성 표현식이 일치할 것을 요구하지는 않습니다. </para>
                        </listitem>
                        <listitem>
                            <para> 마찬가지로 파티션된 테이블의 경우, <command>CREATE TABLE ... PARTITION OF</command>
            에서 
        <literal>GENERATED</literal> 구문 없이 자식 컬럼 정의를 작성하면, 그 <literal>GENERATED</literal>
            구문은 자동으로 부모로부터 복사됩니다. <command>ALTER TABLE ... ATTACH PARTITION</command>는 부모와 자식 컬럼이 생성
            상태에 대해 이미 일치할 것을 요구하지만, 생성 표현식이 일치할 것을 요구하지는 않습니다. </para>
                        </listitem>
                        <listitem>
                            <para>
                                다중 상속의 경우, 한 부모 컬럼이 생성된 컬럼이라면 모든 부모 컬럼이
                                생성된 컬럼이어야 합니다. 모든 컬럼이 같은 생성 표현식을 가지고 있지
                                않다면, 자식에 대해 원하는 표현식을 명시적으로 지정해야 합니다.
                            </para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
        </para>

        <para> 생성된 컬럼 사용 시 추가적인 고려 사항이 적용됩니다. <itemizedlist>
                <listitem>
                    <para>
                        생성된 컬럼은 기본이 되는 베이스 컬럼과는 별도로 접근 권한을 유지합니다.
                        따라서 특정 역할이 생성된 컬럼은 읽을 수 있지만 기본이 되는 베이스 컬럼은
                        읽을 수 없도록 설정하는 것이 가능합니다.
                    </para>

                    <para> 가상 생성 컬럼의 경우, 이는 생성 표현식이 누출 방지(leakproof) 함수만 사용하는 경우에만 완전히 안전합니다(<xref
                            linkend="sql-createfunction" /> 참조). 하지만 이는 시스템에 의해 강제되지는 않습니다. </para>
                </listitem>
                <listitem>
                    <para> 생성 표현식에서 사용되는 함수의 권한은 생성된 컬럼을 사용하는 쿼리에서 생성 표현식을 직접 호출한 것처럼, 실제로 표현식이 실행될
            때(각각 쓰기 또는 읽기 시) 확인됩니다. 생성된 컬럼의 사용자는 생성 표현식에서 사용되는 모든 함수를 호출할 수 있는 권한을 가지고 있어야 합니다. 생성
            표현식의 함수들은 <literal>SECURITY INVOKER</literal> 또는 <literal>SECURITY DEFINER</literal>로
            정의되었는지에 따라 쿼리를 실행하는 사용자 또는 함수 소유자의 권한으로 실행됩니다. </para>
                </listitem>
                <listitem>
                    <para> 생성된 컬럼은 개념적으로 <literal>BEFORE</literal> 트리거가 실행된 후에 갱신됩니다. 따라서 <literal>
            BEFORE</literal> 트리거에서 베이스 컬럼에 대한 변경사항은 생성된 컬럼에 반영됩니다. 하지만 반대로, <literal>BEFORE</literal>
            트리거에서 생성된 컬럼에 접근하는 것은 허용되지 않습니다. </para>
                </listitem>
                <listitem>
                    <para> 생성된 컬럼은 <command>CREATE PUBLICATION</command> 매개변수인 <link
                            linkend="sql-createpublication-params-with-publish-generated-columns">
                            <literal>publish_generated_columns</literal>
                        </link>에
            따라, 또는 <command>CREATE PUBLICATION</command> 명령의 컬럼 목록에 포함시켜 논리적 복제 중에 복제될 수 있습니다. 이는 현재
            저장된 생성 컬럼에 대해서만 지원됩니다. 자세한 내용은 <xref linkend="logical-replication-gencols" />를 참조하십시오. </para>
                </listitem>
            </itemizedlist>
        </para>
    </sect1>

    <sect1 id="ddl-constraints">
        <title>제약 조건</title>

        <indexterm zone="ddl-constraints">
            <primary>constraint</primary>
        </indexterm>

        <para>
            데이터 타입은 테이블에 저장될 수 있는 데이터의 종류를 제한하는 방법입니다.
            하지만 많은 애플리케이션에서 이러한 제약은 너무 광범위합니다. 예를 들어,
            제품 가격을 포함하는 컬럼은 아마도 양수 값만 허용해야 할 것입니다.
            하지만 양수만 허용하는 표준 데이터 타입은 없습니다. 또 다른 문제는
            다른 컬럼이나 행에 대해 컬럼 데이터를 제약하고 싶을 수 있다는 것입니다.
            예를 들어, 제품 정보를 포함하는 테이블에서는 각 제품 번호에 대해
            하나의 행만 있어야 합니다.
        </para>

        <para>
            이를 위해 SQL은 컬럼과 테이블에 제약 조건을 정의할 수 있게 합니다.
            제약 조건은 테이블의 데이터에 대해 원하는 만큼의 제어를 제공합니다.
            사용자가 제약 조건을 위반하는 데이터를 컬럼에 저장하려고 하면 오류가
            발생합니다. 이는 기본값 정의에서 나온 값에도 적용됩니다.
        </para>

        <sect2 id="ddl-constraints-check-constraints">
            <title>체크 제약 조건</title>

            <indexterm>
                <primary>check constraint</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>check</secondary>
            </indexterm>

            <para> 체크 제약 조건은 가장 일반적인 제약 조건 유형입니다. 특정 컬럼의 값이 불리언(참-거짓) 표현식을 만족해야 한다고 지정할 수 있습니다. 예를
                들어, 양수의 제품 가격을 요구하려면 다음과 같이 할 수 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
            </para>

            <para> 보시다시피, 제약 조건 정의는 기본값 정의와 마찬가지로 데이터 타입 뒤에 옵니다. 기본값과 제약 조건은 어떤 순서로든 나열될 수 있습니다. 체크
                제약 조건은 <literal>CHECK</literal> 키워드와 괄호 안의 표현식으로 구성됩니다. 체크 제약 조건 표현식은 제약되는 컬럼을 포함해야
                합니다. 그렇지 않으면 제약 조건이 별 의미가 없을 것입니다. </para>

            <indexterm>
                <primary>constraint</primary>
                <secondary>name</secondary>
            </indexterm>

            <para> 제약 조건에 별도의 이름을 지정할 수도 있습니다. 이는 오류 메시지를 명확하게 하고 제약 조건을 변경해야 할 때 참조할 수 있게 해줍니다. 구문은
                다음과 같습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting> 따라서 이름이 있는
                제약 조건을 지정하려면 <literal>CONSTRAINT</literal> 키워드 다음에 식별자를 쓰고 그 다음에 제약 조건 정의를 씁니다. (이러한
                방식으로 제약 조건 이름을 지정하지 않으면 시스템이 이름을 선택합니다.) </para>

            <para> 체크 제약 조건은 여러 컬럼을 참조할 수도 있습니다. 정상 가격과 할인 가격을 저장하고 할인 가격이 정상 가격보다 낮도록 보장하고 싶다고 가정해
                봅시다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
            </para>

            <para>
                처음 두 제약 조건은 익숙해 보일 것입니다. 세 번째는 새로운 구문을
                사용합니다. 특정 컬럼에 붙어있지 않고 대신 쉼표로 구분된 컬럼 목록에서
                별도의 항목으로 나타납니다. 컬럼 정의와 이러한 제약 조건 정의는
                혼합된 순서로 나열될 수 있습니다.
            </para>

            <para> 우리는 처음 두 제약 조건을 컬럼 제약 조건이라고 하고, 세 번째를 테이블 제약 조건이라고 합니다. 왜냐하면 세 번째는 어떤 하나의 컬럼 정의와도
                별도로 작성되어 있기 때문입니다. 컬럼 제약 조건은 테이블 제약 조건으로도 작성될 수 있지만, 그 반대는 반드시 가능하지 않습니다. 컬럼 제약 조건은
                붙어있는 컬럼만 참조하도록 되어 있기 때문입니다. (<productname>PostgreSQL</productname>은 이 규칙을 강제하지 않지만,
                테이블 정의가 다른 데이터베이스 시스템에서도 작동하기를 원한다면 이를 따라야 합니다.) 위의 예제는 다음과 같이 작성될 수도 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
                또는 다음과 같이도 가능합니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting> 이는 취향의 문제입니다. </para>

            <para> 테이블 제약 조건에도 컬럼 제약 조건과 같은 방식으로 이름을 지정할 수 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
            </para>

            <indexterm>
                <primary>null value</primary>
                <secondary sortas="check constraints">with check constraints</secondary>
            </indexterm>

            <para>
                체크 표현식이 참이나 null 값으로 평가되면 체크 제약 조건이 만족된다는
                점에 주목해야 합니다. 대부분의 표현식은 어떤 피연산자가 null이면
                null 값으로 평가되므로, 제약된 컬럼에 null 값이 들어가는 것을 막지
                못할 것입니다. 컬럼이 null 값을 포함하지 않도록 하려면 다음 섹션에서
                설명하는 not-null 제약 조건을 사용할 수 있습니다.
            </para>

            <note>
                <para>
                    <productname>PostgreSQL</productname>은 검사 중인 새로운 행이나 갱신된 행 이외의 테이블 데이터를 참조하는 <literal>
                    CHECK</literal> 제약 조건을 지원하지 않습니다. 이 규칙을 위반하는 <literal>CHECK</literal> 제약 조건이 간단한
                    테스트에서는 작동하는 것처럼 보일 수 있지만, 제약 조건이 거짓이 되는 상태에 도달하지 않을 것이라고 보장할 수 없습니다(관련된 다른 행의 후속
                    변경으로 인해). 이로 인해 데이터베이스 덤프와 복원이 실패할 수 있습니다. 전체 데이터베이스 상태가 제약 조건과 일치하더라도, 제약 조건을
                    만족하는 순서로 행이 로드되지 않아 복원이 실패할 수 있습니다. 가능하다면 행 간 및 테이블 간 제약을 표현하기 위해 <literal>
                    UNIQUE</literal>, <literal>EXCLUDE</literal>, 또는 <literal>FOREIGN KEY</literal>
                    제약 조건을 사용하십시오. </para>

                <para> 지속적으로 유지되는 일관성 보장이 아닌 행 삽입 시 다른 행에 대한 일회성 검사를 원한다면, 사용자 정의 <link
                        linkend="triggers">트리거</link>를 사용하여 구현할 수 있습니다. (이 접근 방식은 덤프/복원 문제를 피할 수
                    있습니다. <application>pg_dump</application>는 데이터 복원 후에 트리거를 다시 설치하므로 덤프/복원 중에는 검사가
                    강제되지 않기 때문입니다.) </para>
            </note>

            <note>
                <para>
                    <productname>PostgreSQL</productname>은 <literal>CHECK</literal> 제약 조건의 조건이 불변이라고
                    가정합니다. 즉, 동일한 입력 행에 대해 항상 동일한 결과를 제공할 것이라고 가정합니다. 이 가정은 행이 삽입되거나 갱신될 때만 <literal>
                    CHECK</literal> 제약 조건을 검사하고 다른 시점에는 검사하지 않는 것을 정당화합니다. (다른 테이블 데이터를 참조하지 말라는 위의
                    경고는 실제로 이 제한의 특별한 경우입니다.) </para>

                <para> 이 가정을 깨는 일반적인 예는 <literal>CHECK</literal> 표현식에서 사용자 정의 함수를 참조한 다음 해당 함수의 동작을
                    변경하는 것입니다. <productname>PostgreSQL</productname>은 이를 금지하지 않지만, 현재 <literal>CHECK</literal>
                    제약 조건을 위반하는 행이 테이블에 있는지 알아차리지 못할 것입니다. 이로 인해 후속 데이터베이스 덤프와 복원이 실패할 수 있습니다. 이러한
                    변경을 처리하는 권장 방법은 제약 조건을 삭제하고(<command>ALTER TABLE</command> 사용), 함수 정의를 조정한 다음 제약
                    조건을 다시 추가하여 모든 테이블 행에 대해 다시 검사하는 것입니다. </para>
            </note>
        </sect2>

        <sect2 id="ddl-constraints-not-null">
            <title>Not-Null 제약 조건</title>

            <indexterm>
                <primary>not-null constraint</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>NOT NULL</secondary>
            </indexterm>

            <para> not-null 제약 조건은 단순히 컬럼이 null 값을 가질 수 없다고 지정합니다. 구문 예제: <programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
                명시적인 제약 조건 이름도 지정할 수 있습니다. 예를 들면: <programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text <emphasis>CONSTRAINT products_name_not_null</emphasis> NOT NULL,
    price numeric
);
</programlisting>
            </para>

            <para> not-null 제약 조건은 일반적으로 컬럼 제약 조건으로 작성됩니다. 테이블 제약 조건으로 작성하는 구문은 다음과 같습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>NOT NULL product_no</emphasis>,
    <emphasis>NOT NULL name</emphasis>
);
</programlisting>
                하지만 이 구문은 표준이 아니며 주로 <application>pg_dump</application>에서 사용하기 위한 것입니다. </para>

            <para> not-null 제약 조건은 체크 제약 조건 <literal>CHECK (<replaceable>column_name</replaceable>
                IS NOT NULL)</literal>을 생성하는 것과 기능적으로 동일하지만, <productname>PostgreSQL</productname>에서는
                명시적인 not-null 제약 조건을 생성하는 것이 더 효율적입니다. </para>

            <para> 물론 하나의 컬럼에 여러 개의 제약 조건을 가질 수 있습니다. 제약 조건을 차례로 작성하기만 하면 됩니다: <programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
                The order doesn't matter. It does not necessarily determine in which order the
                constraints are checked. </para>

            <para>
                순서는 중요하지 않습니다. 이는 반드시 제약 조건이 검사되는 순서를 결정하지는 않습니다.
            </para>

            <para>
                <literal>NOT NULL</literal> 제약 조건에는 반대되는 것이 있습니다: <literal>NULL</literal> 제약 조건입니다.
                이는 컬럼이 반드시 null이어야 한다는 의미가 아닙니다. 그것은 분명히 쓸모없을 것입니다. 대신, 이는 단순히 컬럼이 null일 수 있다는 기본
                동작을 선택하는 것입니다. <literal>NULL</literal> 제약 조건은 SQL 표준에 없으며 이식 가능한 애플리케이션에서 사용해서는 안
                됩니다. (이는 다른 데이터베이스 시스템과의 호환성을 위해 <productname>PostgreSQL</productname>에 추가된 것입니다.)
                하지만 일부 사용자들은 스크립트 파일에서 제약 조건을 쉽게 전환할 수 있기 때문에 이를 좋아합니다. 예를 들어, 다음과 같이 시작할 수 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
                그리고 나서 원하는 곳에 <literal>NOT</literal> 키워드를 삽입할 수 있습니다. </para>

            <tip>
                <para>
                    대부분의 데이터베이스 설계에서 대다수의 컬럼은 not null로 표시되어야 합니다.
                </para>
            </tip>
        </sect2>

        <sect2 id="ddl-constraints-unique-constraints">
            <title>Unique 제약 조건</title>

            <indexterm>
                <primary>unique constraint</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>unique</secondary>
            </indexterm>

            <para> Unique 제약 조건은 컬럼 또는 컬럼 그룹에 포함된 데이터가 테이블의 모든 행에서 고유하도록 보장합니다. 구문은 다음과 같습니다: <programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
                컬럼 제약 조건으로 작성할 때는 위와 같고, 테이블 제약 조건으로 작성할 때는 아래와 같습니다: <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
                테이블 제약 조건으로 작성할 때는 이렇게 합니다. </para>

            <para> 컬럼 그룹에 대한 unique 제약 조건을 정의하려면 컬럼 이름을 쉼표로 구분하여 테이블 제약 조건으로 작성합니다: <programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
                이는 지정된 컬럼의 값 조합이 테이블 전체에서 고유해야 함을 지정하는 것이며, 개별 컬럼은 고유할 필요가 없습니다(그리고 일반적으로 고유하지
                않습니다). </para>

            <para> 일반적인 방식으로 unique 제약 조건에 고유한 이름을 지정할 수 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
            </para>

            <para> unique 제약 조건을 추가하면 제약 조건에 나열된 컬럼 또는 컬럼 그룹에 대해 자동으로 고유한 B-tree 인덱스가 생성됩니다. 일부 행에만
                적용되는 고유성 제한은 unique 제약 조건으로 작성할 수 없지만, 고유한 <link linkend="indexes-partial">부분 인덱스</link>를
                생성하여 이러한 제한을 강제할 수 있습니다. </para>

            <indexterm>
                <primary>null value</primary>
                <secondary sortas="unique constraints">with unique constraints</secondary>
            </indexterm>

            <para> 일반적으로 제약 조건에 포함된 모든 컬럼의 값이 동일한 행이 테이블에 두 개 이상 있는 경우 unique 제약 조건이 위반됩니다. 기본적으로 이
                비교에서 두 개의 null 값은 동일하지 않은 것으로 간주됩니다. 즉, unique 제약 조건이 있더라도 제약된 컬럼 중 하나 이상에 null 값을
                포함하는 중복 행을 저장할 수 있습니다. 이 동작은 <literal>NULLS NOT DISTINCT</literal> 구문을 추가하여 변경할 수
                있습니다. 예를 들면: <programlisting>
CREATE TABLE products (
    product_no integer UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis>,
    name text,
    price numeric
);
</programlisting> 또는 <programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis> (product_no)
);
</programlisting>
                기본 동작은 <literal>NULLS DISTINCT</literal>를 사용하여 명시적으로 지정할 수 있습니다. unique 제약 조건에서의 기본
                null 처리는 SQL 표준에 따라 구현에 따라 정의되며, 다른 구현에서는 다른 동작을 가질 수 있습니다. 따라서 이식 가능한 애플리케이션을 개발할
                때는 주의해야 합니다. </para>
        </sect2>

        <sect2 id="ddl-constraints-primary-keys">
            <title>기본 키</title>

            <indexterm>
                <primary>primary key</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>primary key</secondary>
            </indexterm>

            <para> 기본 키 제약 조건은 컬럼 또는 컬럼 그룹이 테이블의 행에 대한 고유 식별자로 사용될 수 있음을 나타냅니다. 이는 값이 고유하면서 동시에
                null이 아니어야 함을 요구합니다. 따라서 다음 두 테이블 정의는 동일한 데이터를 허용합니다: <programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
            </para>

            <para> 기본 키는 여러 컬럼에 걸쳐 있을 수 있습니다; 구문은 unique 제약 조건과 유사합니다: <programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
            </para>

            <para> 기본 키를 추가하면 기본 키에 나열된 컬럼 또는 컬럼 그룹에 대해 자동으로 고유한 B-tree 인덱스가 생성되며, 해당 컬럼들이 <literal>NOT
                NULL</literal>로 표시되도록 강제합니다. </para>

            <para> 테이블은 최대 하나의 기본 키만 가질 수 있습니다. (not-null 제약 조건과 결합된 unique 제약 조건은 기능적으로 거의 동일한 것으로,
                여러 개가 있을 수 있지만, 기본 키로 식별될 수 있는 것은 하나뿐입니다.) 관계형 데이터베이스 이론에 따르면 모든 테이블은 기본 키를 가져야 합니다.
                이 규칙은 <productname>PostgreSQL</productname>에서 강제되지는 않지만, 일반적으로 이를 따르는 것이 가장 좋습니다. </para>

            <para>
                기본 키는 문서화 목적과 클라이언트 애플리케이션에 모두 유용합니다.
                예를 들어, 행 값을 수정할 수 있는 GUI 애플리케이션은 행을 고유하게
                식별하기 위해 테이블의 기본 키를 알아야 할 것입니다. 또한 기본 키가
                선언된 경우 데이터베이스 시스템이 이를 활용하는 다양한 방법이 있습니다.
                예를 들어, 기본 키는 해당 테이블을 참조하는 외래 키의 기본 대상 컬럼을
                정의합니다.
            </para>
        </sect2>

        <sect2 id="ddl-constraints-fk">
            <title>외래 키</title>

            <indexterm>
                <primary>foreign key</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>foreign key</secondary>
            </indexterm>

            <indexterm>
                <primary>referential integrity</primary>
            </indexterm>

            <para> 외래 키 제약 조건은 컬럼(또는 컬럼 그룹)의 값이 다른 테이블의 어떤 행에 나타나는 값과 일치해야 함을 지정합니다. 이를 두 관련 테이블 간의 <firstterm>참조
                무결성</firstterm>을 유지한다고 합니다. </para>

            <para> 이전에 여러 번 사용했던 제품 테이블이 있다고 가정해 봅시다: <programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting> 또한 이러한 제품의
                주문을 저장하는 테이블이 있다고 가정해 봅시다. 주문 테이블이 실제로 존재하는 제품의 주문만 포함하도록 보장하고 싶습니다. 따라서 products
                테이블을 참조하는 외래 키 제약 조건을 orders 테이블에 정의합니다: <programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
                이제 products 테이블에 나타나지 않는 non-NULL <structfield>product_no</structfield> 항목으로 주문을
                생성하는 것이 불가능합니다. </para>

            <para> 이러한 상황에서 orders 테이블을 <firstterm>참조하는</firstterm> 테이블이라 하고 products 테이블을 <firstterm>
                참조되는</firstterm> 테이블이라고 합니다. 마찬가지로, 참조하는 컬럼과 참조되는 컬럼이 있습니다. </para>

            <para> 위의 명령을 다음과 같이 줄일 수도 있습니다: <programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
                컬럼 목록이 없는 경우 참조되는 테이블의 기본 키가 참조되는 컬럼으로 사용되기 때문입니다. </para>

            <para>
                일반적인 방식으로 외래 키 제약 조건에 고유한 이름을 지정할 수 있습니다.
            </para>

            <para> 외래 키는 컬럼 그룹도 제약하고 참조할 수 있습니다. 평소와 같이 이는 테이블 제약 조건 형식으로 작성되어야 합니다. 다음은 인위적인 구문
                예제입니다: <programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting> 물론 제약된 컬럼의 수와
                타입은 참조된 컬럼의 수와 타입과 일치해야 합니다. </para>

            <indexterm>
                <primary>foreign key</primary>
                <secondary>self-referential</secondary>
            </indexterm>

            <para> 때로는 외래 키 제약 조건의 <quote>다른 테이블</quote>이 동일한 테이블인 것이 유용할 수 있습니다; 이를 <firstterm>자기
                참조</firstterm> 외래 키라고 합니다. 예를 들어, 테이블의 행이 트리 구조의 노드를 나타내게 하려면 다음과 같이 작성할 수 있습니다: <programlisting>
CREATE TABLE tree (
    node_id integer PRIMARY KEY,
    parent_id integer REFERENCES tree,
    name text,
    ...
);
</programlisting>
                최상위 노드는 NULL <structfield>parent_id</structfield>를 가지며, non-NULL <structfield>
                parent_id</structfield> 항목은 테이블의 유효한 행을 참조하도록 제약됩니다. </para>

            <para> 테이블은 둘 이상의 외래 키 제약 조건을 가질 수 있습니다. 이는 테이블 간의 다대다 관계를 구현하는 데 사용됩니다. 제품과 주문에 대한 테이블이
                있지만, 이제 하나의 주문이 여러 제품을 포함할 수 있도록 하고 싶다고 가정해 봅시다 (위의 구조에서는 허용되지 않았습니다). 다음과 같은 테이블
                구조를 사용할 수 있습니다: <programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting> 마지막 테이블에서 기본 키가 외래 키와 겹치는 것에
                주목하세요. </para>

            <indexterm>
                <primary>CASCADE</primary>
                <secondary>foreign key action</secondary>
            </indexterm>

            <indexterm>
                <primary>RESTRICT</primary>
                <secondary>foreign key action</secondary>
            </indexterm>

            <para> 외래 키는 존재하지 않는 제품에 대한 주문 생성을 막는다는 것을 알고 있습니다. 하지만 주문이 참조하는 제품이 주문 생성 후에 삭제된다면 어떻게
                될까요? SQL에서는 이러한 상황도 처리할 수 있습니다. 직관적으로 몇 가지 옵션이 있습니다: <itemizedlist spacing="compact">
                    <listitem>
                        <para>참조되는 제품의 삭제를 금지</para>
                    </listitem>
                    <listitem>
                        <para>주문도 함께 삭제</para>
                    </listitem>
                    <listitem>
                        <para>다른 방법?</para>
                    </listitem>
                </itemizedlist>
            </para>

            <para> 이를 설명하기 위해, 위의 다대다 관계 예제에서 다음과 같은 정책을 구현해보겠습니다: 누군가가 아직 주문에서 참조되고 있는 제품을 삭제하려고 할
                때 (<literal>order_items</literal>를 통해), 이를 금지합니다. 누군가가 주문을 삭제하면, 주문 항목도 함께 삭제됩니다: <programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
            </para>

            <para> 기본 <literal>ON DELETE</literal> 동작은 <literal>ON DELETE NO ACTION</literal>이며, 이는
                명시적으로 지정할 필요가 없습니다. 이는 참조되는 테이블에서의 삭제가 진행되도록 허용된다는 의미입니다. 하지만 외래 키 제약 조건은 여전히 만족되어야
                하므로, 이 작업은 일반적으로 오류를 발생시킬 것입니다. 그러나 외래 키 제약 조건의 검사는 트랜잭션의 후반부로 지연될 수 있습니다 (이 장에서는
                다루지 않음). 이 경우, <literal>NO ACTION</literal> 설정은 제약 조건이 검사되기 전에 다른 명령이 상황을 <quote>수정</quote>하도록
                허용합니다. 예를 들어, 참조되는 테이블에 적절한 행을 삽입하거나 참조하는 테이블에서 이제 연결이 끊긴 행들을 삭제함으로써 가능합니다. </para>

            <para>
                <literal>RESTRICT</literal>는 <literal>NO ACTION</literal>보다 더 엄격한 설정입니다. 참조되는 행의 삭제를
                방지합니다. <literal>RESTRICT</literal>는 검사를 트랜잭션의 후반부로 지연시키는 것을 허용하지 않습니다. </para>

            <para>
                <literal>CASCADE</literal>는 참조되는 행이 삭제될 때, 이를 참조하는 행(들)도 자동으로 삭제되어야 함을 지정합니다. </para>

            <para> 다른 두 가지 옵션이 있습니다: <literal>SET NULL</literal>과 <literal>SET DEFAULT</literal>.
                이들은 참조되는 행이 삭제될 때 참조하는 행(들)의 참조 열(들)을 각각 null이나 기본값으로 설정하게 합니다. 이러한 옵션들이 제약 조건을 준수하지
                않아도 된다는 의미는 아닙니다. 예를 들어, 동작이 <literal>SET DEFAULT</literal>를 지정하지만 기본값이 외래 키 제약 조건을
                만족시키지 못한다면, 작업은 실패할 것입니다. </para>

            <para> 적절한 <literal>ON DELETE</literal> 동작의 선택은 관련된 테이블들이 나타내는 객체의 종류에 따라 달라집니다. 참조하는
                테이블이 참조되는 테이블이 나타내는 것의 구성 요소이며 독립적으로 존재할 수 없는 경우, <literal>CASCADE</literal>가 적절할 수
                있습니다. 두 테이블이 독립적인 객체를 나타내는 경우, <literal>RESTRICT</literal>나 <literal>NO ACTION</literal>이
                더 적절합니다; 두 객체를 모두 삭제하려는 애플리케이션은 이를 명시적으로 처리하고 두 개의 삭제 명령을 실행해야 할 것입니다. 위의 예에서, 주문
                항목은 주문의 일부이며, 주문이 삭제될 때 자동으로 삭제되는 것이 편리합니다. 하지만 제품과 주문은 서로 다른 것이므로, 제품 삭제가 자동으로 일부
                주문 항목의 삭제를 유발하는 것은 문제가 될 수 있습니다. <literal>SET NULL</literal>이나 <literal>SET DEFAULT</literal>
                동작은 외래 키 관계가 선택적 정보를 나타내는 경우 적절할 수 있습니다. 예를 들어, 제품 테이블에 제품 관리자에 대한 참조가 있고 제품 관리자 항목이
                삭제된다면, 제품의 제품 관리자를 null이나 기본값으로 설정하는 것이 유용할 수 있습니다. </para>

            <para>
                <literal>SET NULL</literal>과 <literal>SET DEFAULT</literal> 동작은 설정할 열의 목록을 지정할 수
                있습니다. 일반적으로 외래 키 제약 조건의 모든 열이 설정되지만, 일부만 설정하는 것이 특수한 경우에 유용합니다. 다음 예제를 살펴보겠습니다: <programlisting>
CREATE TABLE tenants (
    tenant_id integer PRIMARY KEY
);

CREATE TABLE users (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    user_id integer NOT NULL,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE TABLE posts (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    post_id integer NOT NULL,
    author_id integer,
    PRIMARY KEY (tenant_id, post_id),
    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL <emphasis>(author_id)</emphasis>
);
</programlisting>
                열 지정이 없다면, 외래 키는 <literal>tenant_id</literal> 열도 null로 설정하게 되지만, 이 열은 여전히 기본 키의 일부로
                필요합니다. </para>

            <para>
                <literal>ON DELETE</literal>와 유사하게 <literal>ON UPDATE</literal>도 있으며, 이는 참조되는 열이
                변경(갱신)될 때 호출됩니다. 가능한 동작들은 동일하지만, <literal>SET NULL</literal>과 <literal>SET DEFAULT</literal>에
                대해서는 열 목록을 지정할 수 없다는 점이 다릅니다. 이 경우, <literal>CASCADE</literal>는 참조되는 열(들)의 갱신된 값들이
                참조하는 행(들)에 복사되어야 함을 의미합니다. <literal>ON UPDATE NO ACTION</literal>(기본값)과 <literal>ON
                UPDATE RESTRICT</literal> 사이에도 눈에 띄는 차이가 있습니다. 전자는 갱신이 진행되도록 허용하고 외래 키 제약 조건은 갱신 후의
                상태에 대해 검사됩니다. 후자는 갱신 후의 상태가 제약 조건을 여전히 만족시킬 수 있더라도 갱신이 실행되는 것을 방지합니다. 이는 참조되는 행을
                구별되지만 동등하게 비교되는 값으로 갱신하는 것을 방지합니다(예를 들어, 대소문자를 구분하지 않는 콜레이션이 사용되는 문자열 타입의 경우, 다른
                대소문자 변형을 가진 문자열). </para>

            <para> 일반적으로, 참조하는 행의 참조 열 중 어느 하나라도 null이면 외래 키 제약 조건을 만족시킬 필요가 없습니다. <literal>MATCH
                FULL</literal>이 외래 키 선언에 추가되면, 참조하는 행은 모든 참조 열이 null인 경우에만 제약 조건 만족을 피할 수 있습니다(따라서
                null과 non-null 값의 혼합은 <literal>MATCH FULL</literal> 제약 조건을 반드시 실패하게 됩니다). 참조하는 행이 외래
                키 제약 조건을 피할 수 없게 하려면, 참조하는 열(들)을 <literal>NOT NULL</literal>로 선언하십시오. </para>

            <para> 외래 키는 기본 키이거나 고유 제약 조건을 형성하는 열들, 또는 부분적이지 않은 고유 인덱스의 열들을 참조해야 합니다. 이는 참조되는 열들이 항상
                참조하는 행이 일치하는지 효율적으로 찾을 수 있도록 하는 인덱스를 가진다는 것을 의미합니다. 참조되는 테이블에서 행의 <command>DELETE</command>나
                참조되는 열의 <command>UPDATE</command>는 이전 값과 일치하는 행을 찾기 위해 참조하는 테이블을 스캔해야 하므로, 참조하는 열들도
                인덱스를 만드는 것이 좋은 경우가 많습니다. 이것이 항상 필요한 것은 아니며, 인덱스를 만드는 방법에도 많은 선택사항이 있기 때문에, 외래 키 제약
                조건의 선언이 참조하는 열들에 대한 인덱스를 자동으로 생성하지는 않습니다. </para>

            <para> 데이터 갱신과 삭제에 대한 자세한 정보는 <xref linkend="dml" />에 있습니다. 또한 <xref
                    linkend="sql-createtable" />의 참조 문서에서 외래 키 제약 조건 구문에 대한 설명도 참조하십시오. </para>
        </sect2>

        <sect2 id="ddl-constraints-exclusion">
            <title>배제 제약 조건</title>

            <indexterm>
                <primary>exclusion constraint</primary>
            </indexterm>

            <indexterm>
                <primary>constraint</primary>
                <secondary>exclusion</secondary>
            </indexterm>

            <para> 배제 제약 조건은 지정된 연산자를 사용하여 지정된 열이나 표현식에 대해 어떤 두 행을 비교할 때, 이러한 연산자 비교 중 적어도 하나는 거짓이나
                null을 반환하도록 보장합니다. 구문은 다음과 같습니다: <programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
            </para>

            <para> 자세한 내용은 <link linkend="sql-createtable-exclude">
                    <command>CREATE
                        TABLE ... CONSTRAINT ... EXCLUDE</command>
                </link>를 참조하십시오. </para>

            <para>
                배제 제약 조건을 추가하면 제약 조건 선언에서 지정된 유형의
                인덱스가 자동으로 생성됩니다.
            </para>
        </sect2>
    </sect1>

    <sect1 id="ddl-system-columns">
        <title>시스템 열</title>

        <para> 모든 테이블은 시스템에 의해 암시적으로 정의되는 여러 <firstterm>시스템 열</firstterm>을 가지고 있습니다. 따라서 이러한 이름들은
            사용자 정의 열의 이름으로 사용할 수 없습니다. (이러한 제한사항들은 이름이 키워드인지 아닌지와는 별개입니다; 이름을 인용부호로 묶는다고 이러한 제한을 피할
            수 있는 것은 아닙니다.) 이러한 열들에 대해 특별히 신경 쓸 필요는 없습니다; 단지 이들이 존재한다는 것만 알면 됩니다. </para>

        <indexterm>
            <primary>column</primary>
            <secondary>system column</secondary>
        </indexterm>

        <variablelist>
            <varlistentry id="ddl-system-columns-tableoid">
                <term>
                    <structfield>tableoid</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>tableoid</primary>
                    </indexterm>

                    <para> 이 행을 포함하는 테이블의 OID입니다. 이 열은 특히 파티션된 테이블(<xref linkend="ddl-partitioning" />
                        참조)이나 상속 계층(<xref linkend="ddl-inherit" /> 참조)에서 선택하는 쿼리에 유용합니다. 이 열이 없으면 개별
                        행이 어느 테이블에서 왔는지 판단하기 어렵기 때문입니다. <structfield>tableoid</structfield>는 테이블 이름을
                        얻기 위해 <structname>pg_class</structname>의 <structfield>oid</structfield> 열과
                        조인할 수 있습니다. </para>
                </listitem>
            </varlistentry>

            <varlistentry id="ddl-system-columns-xmin">
                <term>
                    <structfield>xmin</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>xmin</primary>
                    </indexterm>

                    <para>
                        이 행 버전을 삽입한 트랜잭션의 식별자(트랜잭션 ID)입니다.
                        (행 버전은 행의 개별 상태입니다; 행의 각 갱신은 동일한
                        논리적 행에 대해 새로운 행 버전을 생성합니다.)
                    </para>
                </listitem>
            </varlistentry>

            <varlistentry id="ddl-system-columns-cmin">
                <term>
                    <structfield>cmin</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>cmin</primary>
                    </indexterm>

                    <para>
                        삽입 트랜잭션 내의 명령 식별자(0부터 시작).
                    </para>
                </listitem>
            </varlistentry>

            <varlistentry id="ddl-system-columns-xmax">
                <term>
                    <structfield>xmax</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>xmax</primary>
                    </indexterm>

                    <para>
                        삭제 트랜잭션의 식별자(트랜잭션 ID), 또는 삭제되지 않은
                        행 버전의 경우 0입니다. 이 열은 가시적인 행 버전에서
                        0이 아닐 수 있습니다. 이는 일반적으로 삭제 트랜잭션이
                        아직 커밋되지 않았거나, 삭제 시도가 롤백되었음을 나타냅니다.
                    </para>
                </listitem>
            </varlistentry>

            <varlistentry id="ddl-system-columns-cmax">
                <term>
                    <structfield>cmax</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>cmax</primary>
                    </indexterm>

                    <para>
                        삭제 트랜잭션 내의 명령 식별자, 또는 0.
                    </para>
                </listitem>
            </varlistentry>

            <varlistentry id="ddl-system-columns-ctid">
                <term>
                    <structfield>ctid</structfield>
                </term>
                <listitem>
                    <indexterm>
                        <primary>ctid</primary>
                    </indexterm>

                    <para> 테이블 내 행 버전의 물리적 위치입니다. <structfield>ctid</structfield>를 사용하여 행 버전을 매우 빠르게
                        찾을 수 있지만, 행이 갱신되거나 <command>VACUUM FULL</command>에 의해 이동되면 행의 <structfield>
                        ctid</structfield>가 변경된다는 점에 유의하십시오. 따라서 <structfield>ctid</structfield>는
                        장기적인 행 식별자로는 쓸모가 없습니다. 논리적 행을 식별하기 위해서는 기본 키를 사용해야 합니다. </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para> 트랜잭션 식별자도 32비트 양입니다. 오래 운영된 데이터베이스에서는 트랜잭션 ID가 순환할 수 있습니다. 이는 적절한 유지보수 절차가 있다면 치명적인
            문제가 아닙니다; 자세한 내용은 <xref linkend="maintenance" />를 참조하십시오. 하지만 장기적으로(10억 번 이상의 트랜잭션) 트랜잭션
            ID의 고유성에 의존하는 것은 현명하지 않습니다. </para>

        <para> 명령 식별자도 32비트 양입니다. 이는 단일 트랜잭션 내에서 2<superscript>32</superscript>(40억) <acronym>SQL</acronym>
            명령이라는 하드 제한을 만듭니다. 실제로 이 제한은 문제가 되지 않습니다 &mdash; 이 제한은 처리되는 행의 수가 아닌 <acronym>SQL</acronym>
            명령의 수에 대한 것임에 주의하십시오. 또한 데이터베이스 내용을 실제로 수정하는 명령만이 명령 식별자를 소비합니다. </para>
    </sect1>

    <sect1 id="ddl-alter">
        <title>테이블 수정</title>

        <indexterm zone="ddl-alter">
            <primary>table</primary>
            <secondary>modifying</secondary>
        </indexterm>

        <para> 테이블을 생성하고 실수를 했거나 애플리케이션의 요구사항이 변경되었을 때, 테이블을 삭제하고 다시 생성할 수 있습니다. 하지만 테이블에 이미 데이터가
            채워져 있거나, 테이블이 다른 데이터베이스 객체에 의해 참조되고 있다면(예를 들어 외래 키 제약 조건) 이는 편리한 옵션이 아닙니다. 따라서 <productname>
            PostgreSQL</productname>은 기존 테이블을 수정하기 위한 명령어 집합을 제공합니다. 이는 테이블에 포함된 데이터를 변경하는 것과는 개념적으로
            구별됩니다: 여기서는 테이블의 정의 또는 구조를 변경하는 것에 관심이 있습니다. </para>

        <para> 다음과 같은 작업이 가능합니다: <itemizedlist spacing="compact">
                <listitem>
                    <para>열 추가</para>
                </listitem>
                <listitem>
                    <para>열 제거</para>
                </listitem>
                <listitem>
                    <para>제약 조건 추가</para>
                </listitem>
                <listitem>
                    <para>제약 조건 제거</para>
                </listitem>
                <listitem>
                    <para>기본값 변경</para>
                </listitem>
                <listitem>
                    <para>열 데이터 타입 변경</para>
                </listitem>
                <listitem>
                    <para>열 이름 변경</para>
                </listitem>
                <listitem>
                    <para>테이블 이름 변경</para>
                </listitem>
            </itemizedlist> 이러한
            모든 작업은 <xref linkend="sql-altertable" /> 명령을 사용하여 수행됩니다. 여기서 제공하는 것보다 자세한 내용은 해당 참조 페이지를
            확인하십시오. </para>

        <sect2 id="ddl-alter-adding-a-column">
            <title>열 추가</title>

            <indexterm>
                <primary>column</primary>
                <secondary>adding</secondary>
            </indexterm>

            <para> 열을 추가하려면 다음과 같은 명령을 사용하십시오: <programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting> 새로운 열은 처음에 지정된
                기본값으로 채워집니다 (<literal>DEFAULT</literal> 절을 지정하지 않으면 null). </para>

            <tip>
                <para>
                    <productname>PostgreSQL</productname> 11부터는 상수 기본값을 가진 열을 추가할 때 <command>ALTER
                    TABLE</command> 문이 실행될 때 테이블의 각 행을 갱신할 필요가 없어졌습니다. 대신, 다음에 행에 접근할 때 기본값이 반환되고,
                    테이블이 다시 작성될 때 적용되어 <command>ALTER TABLE</command>이 큰 테이블에서도 매우 빠르게 실행됩니다. </para>

                <para> 하지만 기본값이 휘발성(예: <function>clock_timestamp()</function>)이면 <command>ALTER
                    TABLE</command>이 실행되는 시점에 계산된 값으로 각 행을 갱신해야 합니다. 잠재적으로 긴 갱신 작업을 피하기 위해, 특히 어차피
                    대부분 기본값이 아닌 값으로 열을 채울 계획이라면 기본값 없이 열을 추가하고, <command>UPDATE</command>를 사용하여 올바른
                    값을 삽입한 다음, 아래 설명된 대로 원하는 기본값을 추가하는 것이 더 나을 수 있습니다. </para>
            </tip>

            <para> 또한 일반적인 구문을 사용하여 동시에 열에 제약 조건을 정의할 수 있습니다: <programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting> 실제로 <command>CREATE
                TABLE</command>의 열 설명에 적용할 수 있는 모든 옵션을 여기서도 사용할 수 있습니다. 하지만 기본값이 주어진 제약 조건을 만족해야 하며,
                그렇지 않으면 <literal>ADD</literal>가 실패한다는 점에 유의하십시오. 또는 새 열을 올바르게 채운 후에 나중에 제약 조건을 추가할 수
                있습니다(아래 참조). </para>

        </sect2>

        <sect2 id="ddl-alter-removing-a-column">
            <title>열 제거</title>

            <indexterm>
                <primary>column</primary>
                <secondary>removing</secondary>
            </indexterm>

            <para> 열을 제거하려면 다음과 같은 명령을 사용하십시오: <programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting> 열에 있던 모든 데이터가
                사라집니다. 해당 열과 관련된 테이블 제약 조건도 삭제됩니다. 하지만 해당 열이 다른 테이블의 외래 키 제약 조건에 의해 참조되고 있다면, <productname>
                PostgreSQL</productname>은 해당 제약 조건을 자동으로 삭제하지 않습니다. <literal>CASCADE</literal>를 추가하여
                열에 의존하는 모든 것을 삭제할 수 있습니다: <programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting> 이 메커니즘에 대한 일반적인 설명은 <xref
                    linkend="ddl-depend" />를 참조하십시오. </para>
        </sect2>

        <sect2 id="ddl-alter-adding-a-constraint">
            <title>제약 조건 추가</title>

            <indexterm>
                <primary>constraint</primary>
                <secondary>adding</secondary>
            </indexterm>

            <para> 제약 조건을 추가하려면 테이블 제약 조건 구문을 사용합니다. 예를 들면: <programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
            </para>

            <para> 일반적으로 테이블 제약 조건으로 작성되지 않는 not-null 제약 조건을 추가하기 위해 다음과 같은 특별한 구문을 사용할 수 있습니다: <programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
                이 명령은 열이 이미 not-null 제약 조건을 가지고 있다면 아무 작업도 하지 않고 조용히 넘어갑니다. </para>

            <para>
                제약 조건은 즉시 검사되므로, 제약 조건을 추가하기 전에
                테이블 데이터가 제약 조건을 만족해야 합니다.
            </para>
        </sect2>

        <sect2 id="ddl-alter-removing-a-constraint">
            <title>제약 조건 제거</title>

            <indexterm>
                <primary>constraint</primary>
                <secondary>removing</secondary>
            </indexterm>

            <para> 제약 조건을 제거하려면 그 이름을 알아야 합니다. 이름을 직접 지정했다면 쉽습니다. 그렇지 않다면 시스템이 생성한 이름을 찾아야 합니다. <application>
                psql</application> 명령의 <literal>\d <replaceable>tablename</replaceable></literal>가
                도움이 될 수 있습니다; 다른 인터페이스들도 테이블 세부 정보를 검사하는 방법을 제공할 수 있습니다. 그런 다음 명령은: <programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
                (<literal>$2</literal>와 같은 생성된 제약 조건 이름을 다룰 때는, 유효한 식별자로 만들기 위해 큰따옴표로 묶어야 한다는 것을 잊지
                마십시오.) </para>

            <para> 열을 삭제할 때와 마찬가지로, 다른 무언가가 의존하는 제약 조건을 삭제하려면 <literal>CASCADE</literal>를 추가해야 합니다.
                예를 들어 외래 키 제약 조건은 참조되는 열(들)의 고유 키나 기본 키 제약 조건에 의존합니다. </para>

            <para> not-null 제약 조건을 삭제하기 위한 간단한 구문도 있습니다: <programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting> 이는
                not-null 제약 조건을 추가하기 위한 <literal>SET NOT NULL</literal> 구문을 반영합니다. 이 명령은 열이 not-null
                제약 조건을 가지고 있지 않다면 아무 작업도 하지 않고 조용히 넘어갑니다. (열은 최대 하나의 not-null 제약 조건만 가질 수 있으므로, 이
                명령이 어떤 제약 조건에 작용하는지 모호하지 않습니다.) </para>
        </sect2>

        <sect2 id="ddl-alter-column-default">
            <title>열의 기본값 변경</title>

            <indexterm>
                <primary>default value</primary>
                <secondary>changing</secondary>
            </indexterm>

            <para> 열의 새로운 기본값을 설정하려면 다음과 같은 명령을 사용하십시오: <programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting> 이는 테이블의 기존
                행들에는 영향을 주지 않으며, 단지 향후 <command>INSERT</command> 명령에 대한 기본값만 변경합니다. </para>

            <para> 기본값을 제거하려면 다음을 사용하십시오: <programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting> 이는 기본값을 null로 설정하는 것과
                실질적으로 동일합니다. 결과적으로, 정의되지 않은 기본값을 삭제하는 것은 오류가 아닙니다. 기본값은 암시적으로 null 값이기 때문입니다. </para>
        </sect2>

        <sect2 id="ddl-alter-column-type">
            <title>열의 데이터 타입 변경</title>

            <indexterm>
                <primary>column data type</primary>
                <secondary>changing</secondary>
            </indexterm>

            <para> 열을 다른 데이터 타입으로 변환하려면 다음과 같은 명령을 사용하십시오: <programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting> 이는 열의 각
                기존 항목이 암시적 형변환에 의해 새로운 타입으로 변환될 수 있는 경우에만 성공합니다. 더 복잡한 변환이 필요한 경우, 이전 값에서 새로운 값을
                계산하는 방법을 지정하는 <literal>USING</literal> 절을 추가할 수 있습니다. </para>

            <para>
                <productname>PostgreSQL</productname>은 열의 기본값(있는 경우)과 열과 관련된 모든 제약 조건도 새로운 타입으로
                변환하려고 시도합니다. 하지만 이러한 변환이 실패하거나 예상치 못한 결과를 생성할 수 있습니다. 종종 타입을 변경하기 전에 열에 대한 모든 제약 조건을
                삭제하고, 나중에 적절히 수정된 제약 조건을 다시 추가하는 것이 가장 좋습니다. </para>
        </sect2>

        <sect2 id="ddl-alter-renaming-column">
            <title>열 이름 변경</title>

            <indexterm>
                <primary>column</primary>
                <secondary>renaming</secondary>
            </indexterm>

            <para> 열의 이름을 변경하려면: <programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
            </para>
        </sect2>

        <sect2 id="ddl-alter-renaming-table">
            <title>테이블 이름 변경</title>

            <indexterm>
                <primary>table</primary>
                <secondary>renaming</secondary>
            </indexterm>

            <para> 테이블의 이름을 변경하려면: <programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
            </para>
        </sect2>
    </sect1>

    <sect1 id="ddl-priv">
        <title>권한</title>

        <indexterm zone="ddl-priv">
            <primary>privilege</primary>
        </indexterm>

        <indexterm>
            <primary>permission</primary>
            <see>privilege</see>
        </indexterm>

        <indexterm zone="ddl-priv">
            <primary>owner</primary>
        </indexterm>

        <indexterm zone="ddl-priv">
            <primary>GRANT</primary>
        </indexterm>

        <indexterm zone="ddl-priv">
            <primary>REVOKE</primary>
        </indexterm>

        <indexterm zone="ddl-priv">
            <primary>
                <acronym>ACL</acronym>
            </primary>
        </indexterm>

        <indexterm zone="ddl-priv-default">
            <primary>privilege</primary>
            <secondary>default</secondary>
        </indexterm>

        <para> 객체가 생성될 때, 소유자가 지정됩니다. 소유자는 일반적으로 생성 명령문을 실행한 역할입니다. 대부분의 객체 유형에서 초기 상태는 소유자(또는
            슈퍼유저)만이 객체에 대해 어떤 작업이든 할 수 있다는 것입니다. 다른 역할이 사용할 수 있도록 하려면, <firstterm>권한</firstterm>을
            부여해야 합니다. </para>

        <para> 다양한 종류의 권한이 있습니다: <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>
            UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, <literal>
            REFERENCES</literal>, <literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>
            CONNECT</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>, <literal>
            USAGE</literal>, <literal>SET</literal>, <literal>ALTER SYSTEM</literal>, 그리고 <literal>
            MAINTAIN</literal>. 특정 객체에 적용 가능한 권한은 객체의 유형(테이블, 함수 등)에 따라 다릅니다. 이러한 권한의 의미에 대한 자세한 내용은
            아래에 나옵니다. 다음 섹션과 장에서는 이러한 권한들이 어떻게 사용되는지도 보여줄 것입니다. </para>

        <para> 객체를 수정하거나 삭제할 수 있는 권리는 객체의 소유자이기 때문에 가지는 것이며, 그 자체로는 부여하거나 취소할 수 없습니다. (하지만 다른 모든 권한과
            마찬가지로, 그 권리는 소유 역할의 구성원들에 의해 상속될 수 있습니다; <xref
                linkend="role-membership" /> 참조.) </para>

        <para> 객체는 해당 객체에 적합한 <command>ALTER</command> 명령을 사용하여 새로운 소유자에게 할당될 수 있습니다. 예를 들면: <programlisting>
ALTER TABLE <replaceable>table_name</replaceable> OWNER TO <replaceable>new_owner</replaceable>;
</programlisting>
            슈퍼유저는 항상 이 작업을 할 수 있습니다; 일반 역할은 현재 객체의 소유자이면서(또는 소유 역할의 권한을 상속받고) 새로운 소유 역할로 <literal>SET
            ROLE</literal>할 수 있는 경우에만 이 작업을 할 수 있습니다. </para>

        <para> 권한을 할당하기 위해서는 <xref linkend="sql-grant" /> 명령이 사용됩니다. 예를 들어, <literal>joe</literal>가
            존재하는 역할이고 <literal>accounts</literal>가 존재하는 테이블이라면, 테이블을 갱신할 수 있는 권한은 다음과 같이 부여할 수 있습니다: <programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
            특정 권한 대신 <literal>ALL</literal>을 작성하면 해당 객체 유형에 관련된 모든 권한을 부여합니다. </para>

        <para> 특별한 <quote>역할</quote> 이름인 <literal>PUBLIC</literal>은 시스템의 모든 역할에 권한을 부여하는 데 사용될 수
            있습니다. 또한, 데이터베이스에 많은 사용자가 있을 때 권한 관리를 돕기 위해 <quote>그룹</quote> 역할을 설정할 수 있습니다 &mdash; 자세한
            내용은 <xref linkend="user-manag" />를 참조하십시오. </para>

        <para> 이전에 부여된 권한을 취소하려면, 적절하게 이름 지어진 <xref linkend="sql-revoke" /> 명령을 사용하십시오: <programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
        </para>

        <para> 일반적으로 객체의 소유자(또는 슈퍼유저)만이 객체에 대한 권한을 부여하거나 취소할 수 있습니다. 하지만 <quote>부여 옵션과 함께</quote>
            권한을 부여할 수 있으며, 이는 수신자에게 다시 다른 사람에게 부여할 수 있는 권리를 줍니다. 부여 옵션이 나중에 취소되면 해당 수신자로부터 권한을 받은 모든
            사람(직접 또는 부여 체인을 통해)이 권한을 잃게 됩니다. 자세한 내용은 <xref linkend="sql-grant" />와 <xref
                linkend="sql-revoke" /> 참조 페이지를 참조하십시오. </para>

        <para>
            객체의 소유자는 자신의 일반 권한을 취소하도록 선택할 수
            있습니다. 예를 들어 테이블을 자신과 다른 사람 모두에게
            읽기 전용으로 만들 수 있습니다. 하지만 소유자는 항상
            모든 부여 옵션을 가지고 있는 것으로 간주되므로,
            언제든지 자신의 권한을 다시 부여할 수 있습니다.
        </para>

        <para> 사용 가능한 권한은 다음과 같습니다: <variablelist>
                <varlistentry id="ddl-priv-select">
                    <term>
                        <literal>SELECT</literal>
                    </term>
                    <listitem>
                        <para> 테이블, 뷰, 구체화된 뷰 또는 다른 테이블과 유사한 객체의 모든 열 또는 특정 열(들)에 대해 <command>SELECT</command>를
            허용합니다. 또한 <command>COPY TO</command>의 사용도 허용합니다. 이 권한은 <command>UPDATE</command>, <command>
            DELETE</command> 또는 <command>MERGE</command>에서 기존 열 값을 참조하는 데도 필요합니다. 시퀀스의 경우, 이 권한은 <function>
            currval</function> 함수의 사용도 허용합니다. 대용량 객체의 경우, 이 권한은 객체를 읽을 수 있게 합니다. </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-insert">
                    <term>
                        <literal>INSERT</literal>
                    </term>
                    <listitem>
                        <para> 테이블, 뷰 등에 새로운 행의 <command>INSERT</command>를 허용합니다. 특정 열(들)에 대해 부여될 수
            있으며, 이 경우 <command>INSERT</command> 명령에서 해당 열만 할당될 수 있습니다(다른 열은 따라서 기본값을 받게 됩니다). 또한 <command>COPY
            FROM</command>의 사용도 허용합니다. </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-update">
                    <term>
                        <literal>UPDATE</literal>
                    </term>
                    <listitem>
                        <para> 테이블, 뷰 등의 모든 열 또는 특정 열(들)에 대한 <command>UPDATE</command>를 허용합니다.
            (실제로는, 어떤 중요한 <command>UPDATE</command> 명령도 <literal>SELECT</literal> 권한도 필요로 할 것입니다.
            갱신할 행을 결정하기 위해, 그리고/또는 열의 새로운 값을 계산하기 위해 테이블 열을 참조해야 하기 때문입니다.) <literal>SELECT ... FOR
            UPDATE</literal>와 <literal>SELECT ... FOR SHARE</literal>도 <literal>SELECT</literal> 권한
            외에 최소한 하나의 열에 대해 이 권한이 필요합니다. 시퀀스의 경우, 이 권한은 <function>nextval</function>과 <function>
            setval</function> 함수의 사용을 허용합니다. 대용량 객체의 경우, 이 권한은 객체를 쓰거나 잘라낼 수 있게 합니다. </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-delete">
                    <term>
                        <literal>DELETE</literal>
                    </term>
                    <listitem>
                        <para> 테이블, 뷰 등에서 행의 <command>DELETE</command>를 허용합니다. (실제로는, 어떤 중요한 <command>
            DELETE</command> 명령도 <literal>SELECT</literal> 권한도 필요로 할 것입니다. 삭제할 행을 결정하기 위해 테이블 열을
            참조해야 하기 때문입니다.) </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-truncate">
                    <term>
                        <literal>TRUNCATE</literal>
                    </term>
                    <listitem>
                        <para> 테이블에 대한 <command>TRUNCATE</command>를 허용합니다. </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-references">
                    <term>
                        <literal>REFERENCES</literal>
                    </term>
                    <listitem>
                        <para>
                            테이블 또는 테이블의 특정 열(들)을 참조하는 외래 키
                            제약 조건의 생성을 허용합니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-trigger">
                    <term>
                        <literal>TRIGGER</literal>
                    </term>
                    <listitem>
                        <para>
                            테이블, 뷰 등에 트리거를 생성할 수 있게 합니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-create">
                    <term>
                        <literal>CREATE</literal>
                    </term>
                    <listitem>
                        <para>
                            데이터베이스의 경우, 데이터베이스 내에 새로운 스키마와
                            발행을 생성할 수 있게 하고, 데이터베이스 내에 신뢰할 수
                            있는 확장을 설치할 수 있게 합니다.
                        </para>
                        <para> 스키마의 경우, 스키마 내에 새로운 객체를 생성할 수 있게 합니다. 기존 객체의 이름을 변경하려면, 객체를 소유하고 <emphasis>있어야
            하며</emphasis> 포함하는 스키마에 대해 이 권한이 있어야 합니다. </para>
                        <para>
                            테이블스페이스의 경우, 테이블스페이스 내에 테이블, 인덱스,
                            임시 파일을 생성할 수 있게 하고, 해당 테이블스페이스를
                            기본 테이블스페이스로 하는 데이터베이스를 생성할 수
                            있게 합니다.
                        </para>
                        <para>
                            이 권한을 취소해도 기존 객체의 존재나 위치는
                            변경되지 않습니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-connect">
                    <term>
                        <literal>CONNECT</literal>
                    </term>
                    <listitem>
                        <para> 권한을 받은 사용자가 데이터베이스에 연결할 수 있게 합니다. 이 권한은 연결 시작 시 검사됩니다(<filename>
            pg_hba.conf</filename>에 의해 부과된 제한 사항을 확인하는 것 외에도). </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-temporary">
                    <term>
                        <literal>TEMPORARY</literal>
                    </term>
                    <listitem>
                        <para>
                            데이터베이스를 사용하는 동안 임시 테이블을 생성할 수
                            있게 합니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-execute">
                    <term>
                        <literal>EXECUTE</literal>
                    </term>
                    <listitem>
                        <para>
                            함수나 프로시저를 호출할 수 있게 합니다. 함수 위에
                            구현된 모든 연산자의 사용도 포함됩니다. 이는 함수와
                            프로시저에 적용할 수 있는 유일한 권한 유형입니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-usage">
                    <term>
                        <literal>USAGE</literal>
                    </term>
                    <listitem>
                        <para>
                            프로시저 언어의 경우, 해당 언어로 함수를 생성하기 위해
                            언어를 사용할 수 있게 합니다. 이는 프로시저 언어에
                            적용할 수 있는 유일한 권한 유형입니다.
                        </para>
                        <para> 스키마의 경우, 스키마에 포함된 객체에 대한 접근을 허용합니다(객체 자체의 권한 요구사항도 충족된다고 가정). 본질적으로
            이는 권한을 받은 사용자가 스키마 내의 객체를 <quote>조회</quote>할 수 있게 합니다. 이 권한이 없어도 시스템 카탈로그를 조회하는 등의 방법으로
            객체 이름을 볼 수는 있습니다. 또한, 이 권한을 취소한 후에도 기존 세션이 이전에 이 조회를 수행한 명령문을 가지고 있을 수 있으므로, 이는 객체 접근을
            막는 완전히 안전한 방법이 아닙니다. </para>
                        <para> 시퀀스의 경우, <function>currval</function>과 <function>nextval</function>
            함수의 사용을 허용합니다. </para>
                        <para> 타입과 도메인의 경우, 테이블, 함수 및 기타 스키마 객체의 생성에 타입이나 도메인을 사용할 수 있게 합니다. (이 권한은
            쿼리에 나타나는 타입의 값과 같은 모든 타입 <quote>사용</quote>을 제어하지는 않습니다. 타입에 의존하는 객체가 생성되는 것만 막습니다. 이 권한의
            주요 목적은 타입에 대한 의존성을 생성할 수 있는 사용자를 제어하는 것으로, 이는 소유자가 나중에 타입을 변경하는 것을 막을 수 있습니다.) </para>
                        <para>
                            외부 데이터 래퍼의 경우, 외부 데이터 래퍼를 사용하여
                            새로운 서버를 생성할 수 있게 합니다.
                        </para>
                        <para>
                            외부 서버의 경우, 서버를 사용하여 외부 테이블을 생성할
                            수 있게 합니다. 권한을 받은 사용자는 해당 서버와 연관된
                            자신의 사용자 매핑을 생성, 변경 또는 삭제할 수도 있습니다.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-set">
                    <term>
                        <literal>SET</literal>
                    </term>
                    <listitem>
                        <para>
                            현재 세션 내에서 서버 구성 매개변수를 새로운 값으로
                            설정할 수 있게 합니다. (이 권한은 어떤 매개변수에도
                            부여될 수 있지만, 일반적으로 슈퍼유저 권한이 필요한
                            매개변수에 대해서만 의미가 있습니다.)
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-alter-system">
                    <term>
                        <literal>ALTER SYSTEM</literal>
                    </term>
                    <listitem>
                        <para>
                            <xref linkend="sql-altersystem" /> 명령을 사용하여 서버 구성 매개변수를 새로운 값으로 설정할 수 있게
            합니다. </para>
                    </listitem>
                </varlistentry>

                <varlistentry id="ddl-priv-maintain">
                    <term>
                        <literal>MAINTAIN</literal>
                    </term>
                    <listitem>
                        <para> 관계에 대해 <command>VACUUM</command>, <command>ANALYZE</command>, <command>
            CLUSTER</command>, <command>REFRESH MATERIALIZED VIEW</command>, <command>REINDEX</command>,
            그리고 <command>LOCK TABLE</command>을 허용합니다. </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            다른 명령에 필요한 권한은 해당 명령의 참조 페이지에 나열되어 있습니다. </para>

        <para id="ddl-priv-default"> PostgreSQL은 객체가 생성될 때 기본적으로 일부 유형의 객체에 대한 권한을 <literal>PUBLIC</literal>에
            부여합니다. 테이블, 테이블 열, 시퀀스, 외부 데이터 래퍼, 외부 서버, 대용량 객체, 스키마, 테이블스페이스 또는 구성 매개변수에 대해서는 기본적으로 <literal>
            PUBLIC</literal>에 어떠한 권한도 부여되지 않습니다. 다른 유형의 객체의 경우, <literal>PUBLIC</literal>에 부여되는 기본
            권한은 다음과 같습니다: 데이터베이스에 대한 <literal>CONNECT</literal>와 <literal>TEMPORARY</literal>(임시 테이블
            생성) 권한; 함수와 프로시저에 대한 <literal>EXECUTE</literal> 권한; 그리고 언어와 데이터 타입(도메인 포함)에 대한 <literal>
            USAGE</literal> 권한. 물론 객체 소유자는 기본 권한과 명시적으로 부여된 권한을 모두 <command>REVOKE</command>할 수
            있습니다. (최대 보안을 위해서는 객체를 생성하는 동일한 트랜잭션에서 <command>REVOKE</command>를 실행하십시오; 그러면 다른 사용자가
            객체를 사용할 수 있는 시간이 없습니다.) 또한 이러한 기본 권한 설정은 <xref
                linkend="sql-alterdefaultprivileges" /> 명령을 사용하여 재정의할 수 있습니다. </para>

        <para>
            <xref linkend="privilege-abbrevs-table" />는 <firstterm>
                <acronym>ACL</acronym>
            </firstterm> 값에서 이러한 권한 유형에 사용되는 한 글자 약어를 보여줍니다.
            이러한 문자들은 아래 나열된 <xref linkend="app-psql" /> 명령의 출력이나 시스템 카탈로그의 <acronym>ACL</acronym> 열을
            볼 때 확인할 수 있습니다. </para>

        <table id="privilege-abbrevs-table">
            <title><acronym>ACL</acronym> 권한 약어</title>
            <tgroup cols="3">
                <colspec colname="col1" colwidth="1*" />
                <colspec colname="col2" colwidth="1*" />
                <colspec colname="col3" colwidth="2*" />
                <thead>
                    <row>
                        <entry>권한</entry>
                        <entry>약어</entry>
                        <entry>해당 객체 유형</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>SELECT</literal>
                        </entry>
                        <entry><literal>r</literal> (<quote>read</quote>)</entry>
                        <entry>
                            <literal>LARGE OBJECT</literal>, <literal>SEQUENCE</literal>, <literal>
                            TABLE</literal>(및 테이블과 유사한 객체), 테이블 열 </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>INSERT</literal>
                        </entry>
                        <entry><literal>a</literal> (<quote>append</quote>)</entry>
                        <entry><literal>TABLE</literal>, 테이블 열</entry>
                    </row>
                    <row>
                        <entry>
                            <literal>UPDATE</literal>
                        </entry>
                        <entry><literal>w</literal> (<quote>write</quote>)</entry>
                        <entry>
                            <literal>LARGE OBJECT</literal>, <literal>SEQUENCE</literal>, <literal>
                            TABLE</literal>, 테이블 열 </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>DELETE</literal>
                        </entry>
                        <entry>
                            <literal>d</literal>
                        </entry>
                        <entry>
                            <literal>TABLE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>TRUNCATE</literal>
                        </entry>
                        <entry>
                            <literal>D</literal>
                        </entry>
                        <entry>
                            <literal>TABLE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>REFERENCES</literal>
                        </entry>
                        <entry>
                            <literal>x</literal>
                        </entry>
                        <entry><literal>TABLE</literal>, 테이블 열</entry>
                    </row>
                    <row>
                        <entry>
                            <literal>TRIGGER</literal>
                        </entry>
                        <entry>
                            <literal>t</literal>
                        </entry>
                        <entry>
                            <literal>TABLE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>CREATE</literal>
                        </entry>
                        <entry>
                            <literal>C</literal>
                        </entry>
                        <entry>
                            <literal>DATABASE</literal>, <literal>SCHEMA</literal>, <literal>
                            TABLESPACE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>CONNECT</literal>
                        </entry>
                        <entry>
                            <literal>c</literal>
                        </entry>
                        <entry>
                            <literal>DATABASE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>TEMPORARY</literal>
                        </entry>
                        <entry>
                            <literal>T</literal>
                        </entry>
                        <entry>
                            <literal>DATABASE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>EXECUTE</literal>
                        </entry>
                        <entry>
                            <literal>X</literal>
                        </entry>
                        <entry><literal>FUNCTION</literal>, <literal>PROCEDURE</literal></entry>
                    </row>
                    <row>
                        <entry>
                            <literal>USAGE</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>DOMAIN</literal>, <literal>FOREIGN DATA WRAPPER</literal>, <literal>FOREIGN
                            SERVER</literal>, <literal>LANGUAGE</literal>, <literal>SCHEMA</literal>
                            ,
       <literal>SEQUENCE</literal>, <literal>TYPE</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>SET</literal>
                        </entry>
                        <entry>
                            <literal>s</literal>
                        </entry>
                        <entry>
                            <literal>PARAMETER</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>ALTER SYSTEM</literal>
                        </entry>
                        <entry>
                            <literal>A</literal>
                        </entry>
                        <entry>
                            <literal>PARAMETER</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>MAINTAIN</literal>
                        </entry>
                        <entry>
                            <literal>m</literal>
                        </entry>
                        <entry>
                            <literal>TABLE</literal>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <para>
            <xref linkend="privileges-summary-table" />는 위에서 보여준 약어를 사용하여 각 SQL 객체 유형에 대해 사용 가능한 권한을
            요약합니다. 또한 각 객체 유형의 권한 설정을 검사하는 데 사용할 수 있는 <application>psql</application> 명령도 보여줍니다. </para>

        <table id="privileges-summary-table">
            <title>접근 권한 요약</title>
            <tgroup cols="4">
                <colspec colname="col1" colwidth="2*" />
                <colspec colname="col2" colwidth="1*" />
                <colspec colname="col3" colwidth="1*" />
                <colspec colname="col4" colwidth="1*" />
                <thead>
                    <row>
                        <entry>객체 유형</entry>
                        <entry>모든 권한</entry>
                        <entry>기본 <literal>PUBLIC</literal> 권한</entry>
                        <entry><application>psql</application> 명령</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>DATABASE</literal>
                        </entry>
                        <entry>
                            <literal>CTc</literal>
                        </entry>
                        <entry>
                            <literal>Tc</literal>
                        </entry>
                        <entry>
                            <literal>\l</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>DOMAIN</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>\dD+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry><literal>FUNCTION</literal> 또는 <literal>PROCEDURE</literal></entry>
                        <entry>
                            <literal>X</literal>
                        </entry>
                        <entry>
                            <literal>X</literal>
                        </entry>
                        <entry>
                            <literal>\df+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>FOREIGN DATA WRAPPER</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dew+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>FOREIGN SERVER</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\des+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>LANGUAGE</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>\dL+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>LARGE OBJECT</literal>
                        </entry>
                        <entry>
                            <literal>rw</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dl+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>PARAMETER</literal>
                        </entry>
                        <entry>
                            <literal>sA</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dconfig+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>SCHEMA</literal>
                        </entry>
                        <entry>
                            <literal>UC</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dn+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>SEQUENCE</literal>
                        </entry>
                        <entry>
                            <literal>rwU</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dp</literal>
                        </entry>
                    </row>
                    <row>
                        <entry><literal>TABLE</literal>(및 테이블과 유사한 객체)</entry>
                        <entry>
                            <literal>arwdDxtm</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dp</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>테이블 열</entry>
                        <entry>
                            <literal>arwx</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\dp</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>TABLESPACE</literal>
                        </entry>
                        <entry>
                            <literal>C</literal>
                        </entry>
                        <entry>없음</entry>
                        <entry>
                            <literal>\db+</literal>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>TYPE</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>U</literal>
                        </entry>
                        <entry>
                            <literal>\dT+</literal>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <para>
            <indexterm>
                <primary>
                    <type>aclitem</type>
                </primary>
            </indexterm> 특정 객체에 대해
            부여된 권한은 <type>aclitem</type> 항목의 목록으로 표시되며, 각각 다음 형식을 가집니다: <synopsis>
<replaceable>피부여자</replaceable><literal>=</literal><replaceable>권한-약어</replaceable><optional><literal>*</literal></optional>...<literal>/</literal><replaceable>부여자</replaceable>
</synopsis>
            각 <type>aclitem</type>은 특정 부여자가 부여한 한 피부여자의 모든 권한을 나열합니다. 특정 권한은 <xref
                linkend="privilege-abbrevs-table" />의 한 글자 약어로 표시되며, 부여 옵션과 함께 권한이 부여된 경우 <literal>*</literal>가
            추가됩니다. 예를 들어, <literal>calvin=r*w/hobbes</literal>는 역할 <literal>calvin</literal>이 부여 옵션이
            있는 <literal>SELECT</literal>(<literal>r</literal>) 권한(<literal>*</literal>)과 부여할 수 없는 <literal>
            UPDATE</literal>(<literal>w</literal>) 권한을 가지고 있으며, 둘 다 역할 <literal>hobbes</literal>가
            부여했음을 나타냅니다. <literal>calvin</literal>이 다른 부여자로부터 같은 객체에 대한 권한을 가지고 있다면, 그것들은 별도의 <type>
            aclitem</type> 항목으로 나타날 것입니다. <type>aclitem</type>의 빈 피부여자 필드는 <literal>PUBLIC</literal>을
            나타냅니다. </para>

        <para> 예를 들어, 사용자 <literal>miriam</literal>이 <literal>mytable</literal> 테이블을 생성하고 다음을 수행했다고
            가정해 봅시다: <programlisting>
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
</programlisting> 그러면 <application>psql</application>의 <literal>
            \dp</literal> 명령은 다음을 보여줄 것입니다: <programlisting>
=&gt; \dp mytable
                                  Access privileges
 Schema |  Name   | Type  |   Access privileges    |   Column privileges   | Policies
--------+---------+-------+------------------------+-----------------------+----------
 public | mytable | table | miriam=arwdDxtm/miriam+| col1:                +|
        |         |       | =r/miriam             +|   miriam_rw=rw/miriam |
        |         |       | admin=arw/miriam       |                       |
(1 row)
</programlisting>
        </para>

        <para> 주어진 객체에 대해 <quote>Access privileges</quote> 열이 비어 있다면, 이는 객체가 기본 권한을 가지고 있다는 것을
            의미합니다(즉, 관련 시스템 카탈로그의 권한 항목이 null임). 기본 권한은 항상 소유자에 대한 모든 권한을 포함하며, 위에서 설명한 대로 객체 유형에 따라 <literal>
            PUBLIC</literal>에 대한 일부 권한을 포함할 수 있습니다. 객체에 대한 첫 번째 <command>GRANT</command> 또는 <command>
            REVOKE</command>는 기본 권한을 인스턴스화하고(예: <literal>miriam=arwdDxt/miriam</literal> 생성) 지정된 요청에
            따라 수정합니다. 마찬가지로, <quote>Column privileges</quote>에는 기본값이 아닌 권한을 가진 열에 대해서만 항목이 표시됩니다.
            (참고: 이 목적에서 <quote>기본 권한</quote>은 항상 객체 유형에 대한 내장된 기본 권한을 의미합니다. <command>ALTER DEFAULT
            PRIVILEGES</command> 명령의 영향을 받은 객체는 항상 <command>ALTER</command>의 효과를 포함하는 명시적 권한 항목과 함께
            표시됩니다.) </para>

        <para> 소유자의 암시적 부여 옵션은 접근 권한 표시에 표시되지 않습니다. <literal>*</literal>는 부여 옵션이 누군가에게 명시적으로 부여되었을
            때만 나타납니다. </para>

        <para> 객체의 권한 항목이 null이 아니지만 비어 있을 때 <quote>Access
                privileges</quote> 열은 <literal>(none)</literal>을 보여줍니다. 이는 객체의 소유자에게도 어떤 권한도 부여되지
            않았다는 것을 의미하며 &mdash; 드문 상황입니다. (소유자는 이 경우에도 암시적 부여 옵션을 가지고 있으므로 자신의 권한을 다시 부여할 수 있습니다;
            하지만 현재는 아무 권한도 없습니다.) </para>
    </sect1>

    <sect1 id="ddl-rowsecurity">
        <title>행 보안 정책</title>

        <indexterm zone="ddl-rowsecurity">
            <primary>row-level security</primary>
        </indexterm>

        <indexterm zone="ddl-rowsecurity">
            <primary>policy</primary>
        </indexterm>

        <para>
            <xref linkend="sql-grant" />를 통해 사용할 수 있는 SQL 표준 <link linkend="ddl-priv">권한 시스템</link>
            외에도, 테이블은 <firstterm>행 보안 정책</firstterm>을 가질 수 있어서 사용자별로 일반 쿼리가 반환하거나 데이터 수정 명령이 삽입, 갱신
            또는 삭제할 수 있는 행을 제한할 수 있습니다. 이 기능은 <firstterm>행 수준 보안</firstterm>이라고도 합니다. 기본적으로 테이블은 어떤
            정책도 가지고 있지 않으므로, SQL 권한 시스템에 따라 테이블에 대한 접근 권한이 있는 사용자는 모든 행을 동등하게 쿼리하거나 갱신할 수 있습니다. </para>

        <para> 테이블에서 행 보안이 활성화되면(<link
                linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
                SECURITY</link>로), 행을 선택하거나 수정하기 위한 모든 일반 접근은 행 보안 정책에 의해 허용되어야 합니다. (하지만 테이블의 소유자는
            일반적으로 행 보안 정책의 적용을 받지 않습니다.) 테이블에 정책이 없다면, 기본 거부 정책이 사용되어 어떤 행도 보이지 않고 수정할 수 없습니다. <command>
            TRUNCATE</command>와 <literal>REFERENCES</literal>와 같은 전체 테이블에 적용되는 작업은 행 보안의 적용을 받지
            않습니다. </para>

        <para> 행 보안 정책은 명령에 특정하거나, 역할에 특정하거나, 둘 다일 수 있습니다. 정책은 <literal>ALL</literal> 명령에 적용되거나, <literal>
            SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal> 또는 <literal>
            DELETE</literal>에 적용되도록 지정될 수 있습니다. 여러 역할을 주어진 정책에 할당할 수 있으며, 일반적인 역할 멤버십과 상속 규칙이 적용됩니다. </para>

        <para> 정책에 따라 어떤 행이 보이거나 수정 가능한지 지정하려면 Boolean 결과를 반환하는 표현식이 필요합니다. 이 표현식은 사용자의 쿼리에서 온 조건이나
            함수보다 먼저 각 행에 대해 평가됩니다. (이 규칙의 유일한 예외는 정보를 누출하지 않는 것이 보장된 <literal>leakproof</literal>
            함수입니다; 옵티마이저는 행 보안 검사보다 앞서 이러한 함수를 적용하도록 선택할 수 있습니다.) 표현식이 <literal>true</literal>를 반환하지
            않는 행은 처리되지 않습니다. 보이는 행과 수정이 허용된 행을 독립적으로 제어하기 위해 별도의 표현식을 지정할 수 있습니다. 정책 표현식은 쿼리의 일부로
            실행되며 쿼리를 실행하는 사용자의 권한으로 실행되지만, security-definer 함수를 사용하여 호출하는 사용자가 사용할 수 없는 데이터에 접근할 수
            있습니다. </para>

        <para> 슈퍼유저와 <literal>BYPASSRLS</literal> 속성을 가진 역할은 테이블에 접근할 때 항상 행 보안 시스템을 우회합니다. 테이블 소유자도
            일반적으로 행 보안을 우회하지만, <link
                linkend="sql-altertable">ALTER TABLE ... FORCE ROW LEVEL
                SECURITY</link>로 행 보안의 적용을 받도록 선택할 수 있습니다. </para>

        <para>
            행 보안의 활성화와 비활성화, 그리고 테이블에 정책을 추가하는
            것은 항상 테이블 소유자만의 권한입니다.
        </para>

        <para> 정책은 <xref linkend="sql-createpolicy" /> 명령을 사용하여 생성하고, <xref
                linkend="sql-alterpolicy" /> 명령을 사용하여 변경하고, <xref linkend="sql-droppolicy" /> 명령을
            사용하여 삭제합니다. 주어진 테이블에 대해 행 보안을 활성화하고 비활성화하려면, <xref linkend="sql-altertable" /> 명령을
            사용하십시오. </para>

        <para>
            각 정책은 이름을 가지며 테이블에 대해 여러 정책을 정의할
            수 있습니다. 정책은 테이블별로 지정되므로, 테이블의 각
            정책은 고유한 이름을 가져야 합니다. 다른 테이블은 같은
            이름의 정책을 가질 수 있습니다.
        </para>

        <para> 주어진 쿼리에 여러 정책이 적용될 때, 그것들은 (기본값인) 허용 정책의 경우 <literal>OR</literal>을 사용하거나 제한 정책의 경우 <literal>
            AND</literal>를 사용하여 결합됩니다. <literal>OR</literal> 동작은 주어진 역할이 자신이 속한 모든 역할의 권한을 가진다는 규칙과
            유사합니다. 허용 vs. 제한 정책에 대해서는 아래에서 자세히 설명합니다. </para>

        <para> 간단한 예로, <literal>managers</literal> 역할의 구성원만이 행에 접근할 수 있고, 자신의 계정의 행만 접근할 수 있도록 <literal>
            account</literal> 관계에 정책을 생성하는 방법은 다음과 같습니다: </para>

        <programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>

        <para> 위의 정책은 암시적으로 <literal>USING</literal> 절과 동일한 <literal>WITH CHECK</literal> 절을 제공하므로,
            제약 조건은 명령에 의해 선택된 행(따라서 관리자는 다른 관리자에 속한 기존 행을 <command>SELECT</command>, <command>UPDATE</command>
            또는 <command>DELETE</command>할 수 없음)과 명령에 의해 수정된 행(따라서 <command>INSERT</command>나 <command>
            UPDATE</command>를 통해 다른 관리자에 속하는 행을 생성할 수 없음) 모두에 적용됩니다. </para>

        <para> 역할이 지정되지 않거나 특별한 사용자 이름인 <literal>PUBLIC</literal>이 사용되면, 정책은 시스템의 모든 사용자에게 적용됩니다. <literal>
            users</literal> 테이블에서 모든 사용자가 자신의 행만 접근할 수 있도록 하려면, 간단한 정책을 사용할 수 있습니다: </para>

        <programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>

        <para>
            이는 이전 예제와 유사하게 작동합니다.
        </para>

        <para> 테이블에 추가되는 행과 보이는 행에 대해 서로 다른 정책을 사용하려면, 여러 정책을 결합할 수 있습니다. 이 정책 쌍은 모든 사용자가 <literal>
            users</literal> 테이블의 모든 행을 볼 수 있지만 자신의 행만 수정할 수 있도록 허용합니다: </para>

        <programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>

        <para>
            <command>SELECT</command> 명령에서, 이 두 정책은 <literal>OR</literal>을 사용하여 결합되어 모든 행을 선택할 수 있다는
            순 효과를 가집니다. 다른 명령 유형에서는 두 번째 정책만 적용되므로, 효과는 이전과 동일합니다. </para>

        <para> 행 보안은 <command>ALTER TABLE</command> 명령으로도 비활성화할 수 있습니다. 행 보안을 비활성화해도 테이블에 정의된 정책은
            제거되지 않습니다; 단순히 무시됩니다. 그러면 테이블의 모든 행이 표준 SQL 권한 시스템에 따라 보이고 수정 가능합니다. </para>

        <para> 아래는 이 기능을 운영 환경에서 어떻게 사용할 수 있는지에 대한 더 큰 예제입니다. <literal>passwd</literal> 테이블은 Unix
            패스워드 파일을 모방합니다: </para>

        <programlisting>
-- 간단한 passwd-파일 기반 예제
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- 관리자
CREATE ROLE bob;    -- 일반 사용자
CREATE ROLE alice;  -- 일반 사용자

-- 테이블 채우기
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- 테이블에 행 수준 보안을 활성화하는 것을 잊지 마세요
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- 정책 생성
-- 관리자는 모든 행을 보고 어떤 행이든 추가할 수 있음
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- 일반 사용자는 모든 행을 볼 수 있음
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- 일반 사용자는 자신의 기록을 갱신할 수 있지만,
-- 일반 사용자가 설정할 수 있는 셸을 제한함
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- 관리자에게 모든 일반 권한을 허용
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- 사용자는 공개 열에 대해서만 선택 접근 권한을 얻음
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- 사용자가 특정 열을 갱신할 수 있도록 허용
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

        <para>
            다른 보안 설정과 마찬가지로, 시스템이 예상대로 작동하는지 테스트하고 확인하는 것이 중요합니다. 아래의 예시를 사용하여 권한 시스템이 올바르게 작동하는지
            보여줍니다.
        </para>

        <programlisting>
-- 관리자는 모든 행과 필드를 볼 수 있음
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Alice가 할 수 있는 작업 테스트
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for table passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for table passwd
-- Alice는 자신의 real_name만 변경할 수 있고, 다른 사용자의 것은 변경할 수 없음
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for table passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for table passwd
-- Alice는 자신의 비밀번호를 변경할 수 있음; RLS는 다른 행의 업데이트를 자동으로 방지함
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

        <para> 지금까지 구성된 모든 정책은 허용 정책이었습니다. 이는 여러 정책이 적용될 때 <quote>OR</quote> 부울 연산자를 사용하여 결합된다는 것을
            의미합니다. 허용 정책을 사용하여 의도된 경우에만 행에 접근할 수 있도록 구성할 수 있지만, 허용 정책과 제한 정책을 결합하는 것이 더 간단할 수
            있습니다(레코드는 제한 정책을 통과해야 하며 <quote>AND</quote> 부울 연산자를 사용하여 결합됩니다). 위의 예시를 기반으로, 관리자가 <literal>
            passwd</literal> 테이블의 레코드에 접근하기 위해서는 로컬 Unix 소켓을 통해 연결되어야 한다는 제한 정책을 추가합니다: </para>

        <programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>

        <para>
            이제 네트워크를 통해 연결하는 관리자는 제한 정책으로 인해 어떤 레코드도 볼 수 없다는 것을 확인할 수 있습니다:
        </para>

        <programlisting>
=&gt; SELECT current_user;
 current_user
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr
------------------
 127.0.0.1
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>

        <para> 고유키 또는 기본 키 제약 조건 및 외래 키 참조와 같은 참조 무결성 검사는 데이터 무결성을 유지하기 위해 항상 행 보안을 우회합니다. 이러한 참조
            무결성 검사를 통한 <quote>은닉 채널</quote> 정보 유출을 방지하기 위해 스키마와 행 수준 정책을 개발할 때 주의를 기울여야 합니다. </para>

        <para> 일부 상황에서는 행 보안이 적용되지 않도록 확인하는 것이 중요합니다. 예를 들어, 백업을 수행할 때 행 보안으로 인해 일부 행이 백업에서 자동으로
            누락된다면 재앙이 될 수 있습니다. 이러한 상황에서는 <xref linkend="guc-row-security" /> 구성 매개변수를 <literal>off</literal>로
            설정할 수 있습니다. 이것이 행 보안을 직접 우회하는 것은 아닙니다; 대신 정책에 의해 쿼리 결과가 필터링될 경우 오류를 발생시킵니다. 그러면 오류의 원인을
            조사하고 수정할 수 있습니다. </para>

        <para> 위의 예시에서 정책 표현식은 접근하거나 업데이트할 행의 현재 값만을 고려합니다. 이는 가장 단순하고 성능이 좋은 경우입니다. 가능하다면 이런 방식으로 행
            보안 애플리케이션을 설계하는 것이 가장 좋습니다. 정책 결정을 위해 다른 행이나 다른 테이블을 참조해야 하는 경우, 정책 표현식에서 하위 <command>
            SELECT</command> 또는 <command>SELECT</command>를 포함하는 함수를 사용하여 수행할 수 있습니다. 그러나 이러한 접근이
            주의하지 않으면 정보 유출을 허용할 수 있는 경쟁 조건을 만들 수 있다는 점에 주의하십시오. 예시로, 다음과 같은 테이블 설계를 고려해보십시오: </para>

        <programlisting>
-- 권한 그룹 정의
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice가 관리자임
GRANT SELECT ON groups TO public;

-- 사용자의 권한 수준 정의
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- 보호해야 할 정보를 담고 있는 테이블
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- 보안 group_id가 해당 행의 group_id보다 크거나 같은 사용자에게
-- 행이 보이거나 업데이트 가능해야 함
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- information 테이블 보호를 위해 RLS에만 의존함
GRANT ALL ON information TO public;
</programlisting>

        <para> 이제 <literal>alice</literal>가 <quote>slightly secret</quote> 정보를 변경하려고 하는데, <literal>
            mallory</literal>를 해당 행의 새로운 내용을 신뢰할 수 없다고 판단하여 다음과 같이 실행한다고 가정해 보겠습니다: </para>

        <programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>

        <para> 이것은 안전해 보입니다; <literal>mallory</literal>가 <quote>secret from mallory</quote> 문자열을 볼 수
            있는 시간 창이 없어 보입니다. 하지만, 여기에는 경쟁 조건이 있습니다. 만약 <literal>mallory</literal>가 동시에 다음과 같은 작업을
            수행하고 있다면, <programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting> 그리고 그의 트랜잭션이 <literal>READ COMMITTED</literal>
            모드인 경우, <quote>secret from mallory</quote>를 볼 수 있는 가능성이 있습니다. 이는 그의 트랜잭션이 <literal>alice</literal>의
            트랜잭션 직후에 <structname>information</structname> 행에 도달할 때 발생합니다. <literal>FOR UPDATE</literal>
            절 덕분에 <literal>alice</literal>의 트랜잭션이 커밋될 때까지 기다렸다가 업데이트된 행 내용을 가져옵니다. 하지만, <structname>
            users</structname>에서의 암시적 <command>SELECT</command>에 대해서는 업데이트된 행을 가져오지 <emphasis>않습니다</emphasis>.
            왜냐하면 해당 하위 <command>SELECT</command>에는 <literal>FOR UPDATE</literal>가 없었기 때문입니다; 대신 <structname>
            users</structname> 행은 쿼리 시작 시 생성된 스냅샷으로 읽힙니다. 따라서, 정책 표현식은 <literal>mallory</literal>의
            이전 권한 수준을 테스트하게 되어 업데이트된 행을 볼 수 있게 됩니다. </para>

        <para> 이 문제를 해결하는 여러 가지 방법이 있습니다. 한 가지 간단한 답은 행 보안 정책의 하위 <command>SELECT</command>에서 <literal>SELECT
            ... FOR SHARE</literal>를 사용하는 것입니다. 하지만, 이는 영향을 받는 사용자들에게 참조된 테이블(여기서는 <structname>users</structname>)에
            대한 <literal>UPDATE</literal> 권한을 부여해야 하며, 이는 바람직하지 않을 수 있습니다. (하지만 다른 행 보안 정책을 적용하여 그들이
            실제로 그 권한을 행사하는 것을 방지할 수 있습니다; 또는 하위 <command>SELECT</command>를 보안 정의자 함수에 포함시킬 수 있습니다.)
            또한, 참조된 테이블에 대한 행 공유 잠금의 과도한 동시 사용은 성능 문제를 야기할 수 있으며, 특히 해당 테이블의 업데이트가 빈번한 경우 더욱 그렇습니다.
            참조된 테이블의 업데이트가 드문 경우에 실용적인 또 다른 해결책은 업데이트 시 참조된 테이블에 <literal>ACCESS EXCLUSIVE</literal>
            잠금을 걸어 동시 트랜잭션이 이전 행 값을 검사할 수 없게 하는 것입니다. 또는 참조된 테이블의 업데이트를 커밋한 후 새로운 보안 상황에 의존하는 변경을 하기
            전에 모든 동시 트랜잭션이 종료될 때까지 기다릴 수도 있습니다. </para>

        <para> 추가 세부사항은 <xref linkend="sql-createpolicy" />와 <xref linkend="sql-altertable" />를
            참조하십시오. </para>

    </sect1>

    <sect1 id="ddl-schemas">
        <title>스키마</title>

        <indexterm zone="ddl-schemas">
            <primary>schema</primary>
        </indexterm>

        <para>
            <productname>PostgreSQL</productname> 데이터베이스 클러스터는 하나 이상의 명명된 데이터베이스를 포함합니다. 역할과 몇 가지 다른
            객체 유형은 전체 클러스터에서 공유됩니다. 서버에 대한 클라이언트 연결은 연결 요청에서 지정된 단일 데이터베이스의 데이터에만 접근할 수 있습니다. </para>

        <note>
            <para> 클러스터의 사용자가 반드시 클러스터의 모든 데이터베이스에 접근할 수 있는 권한을 가지고 있는 것은 아닙니다. 역할 이름의 공유는 동일한 클러스터의
                두 데이터베이스에 <literal>joe</literal>와 같은 다른 이름의 역할이 있을 수 없다는 것을 의미합니다; 하지만 시스템은 <literal>
                joe</literal>가 일부 데이터베이스에만 접근할 수 있도록 구성될 수 있습니다. </para>
        </note>

        <para> 데이터베이스는 하나 이상의 명명된 <firstterm>스키마</firstterm>를 포함하며, 이는 다시 테이블을 포함합니다. 스키마는 또한 데이터
            타입, 함수, 연산자를 포함한 다른 종류의 명명된 객체도 포함합니다. 하나의 스키마 내에서 같은 유형의 두 객체는 동일한 이름을 가질 수 없습니다. 또한,
            테이블, 시퀀스, 인덱스, 뷰, 구체화된 뷰, 외래 테이블은 동일한 네임스페이스를 공유하므로, 예를 들어 인덱스와 테이블이 같은 스키마에 있는 경우 서로 다른
            이름을 가져야 합니다. 같은 객체 이름은 충돌 없이 다른 스키마에서 사용될 수 있습니다; 예를 들어, <literal>schema1</literal>과 <literal>
            myschema</literal> 모두 <literal>mytable</literal>이라는 테이블을 포함할 수 있습니다. 데이터베이스와 달리, 스키마는
            엄격하게 분리되어 있지 않습니다: 사용자는 권한이 있다면 연결된 데이터베이스의 모든 스키마에 있는 객체에 접근할 수 있습니다. </para>

        <para> 스키마를 사용하고자 하는 이유는 여러 가지가 있습니다: <itemizedlist>
                <listitem>
                    <para>
                        여러 사용자가 서로 간섭하지 않고 하나의 데이터베이스를 사용할 수 있게 하기 위해서입니다.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        데이터베이스 객체를 논리적 그룹으로 구성하여 더 관리하기 쉽게 만들기 위해서입니다.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        서드파티 애플리케이션을 별도의 스키마에 둠으로써 다른 객체의 이름과 충돌하지 않게 할 수 있습니다.
                    </para>
                </listitem>
            </itemizedlist>
            스키마는 운영체제 수준의 디렉터리와 유사하지만, 스키마는 중첩될 수 없다는 점이 다릅니다. </para>

        <sect2 id="ddl-schemas-create">
            <title>스키마 생성</title>

            <indexterm zone="ddl-schemas-create">
                <primary>schema</primary>
                <secondary>creating</secondary>
            </indexterm>

            <para> 스키마를 생성하려면 <xref linkend="sql-createschema" /> 명령을 사용하십시오. 원하는 이름을 스키마에 지정하면 됩니다.
                예를 들면: <programlisting>
CREATE SCHEMA myschema;
</programlisting>
            </para>

            <indexterm>
                <primary>qualified name</primary>
            </indexterm>

            <indexterm>
                <primary>name</primary>
                <secondary>qualified</secondary>
            </indexterm>

            <para> 스키마에서 객체를 생성하거나 접근하려면, 스키마 이름과 테이블 이름을 점으로 구분한 <firstterm>정규화된 이름</firstterm>을
                작성하십시오: <synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
                이는 테이블 이름이 필요한 모든 곳에서 작동하며, 여기에는 다음 장에서 설명할 테이블 수정 명령과 데이터 접근 명령이 포함됩니다. (간단히 하기 위해
                테이블에 대해서만 이야기하겠지만, 같은 개념이 타입이나 함수와 같은 다른 종류의 명명된 객체에도 적용됩니다.) </para>

            <para> 실제로는 더 일반적인 문법인 <synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
                도 사용할 수 있지만, 현재는 SQL 표준과의 형식적 호환성을 위한 것일 뿐입니다. 데이터베이스 이름을 작성하는 경우, 연결된 데이터베이스와 동일해야
                합니다. </para>

            <para> 따라서 새 스키마에 테이블을 생성하려면 다음과 같이 사용하십시오: <programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
            </para>

            <indexterm>
                <primary>schema</primary>
                <secondary>removing</secondary>
            </indexterm>

            <para> 스키마가 비어 있는 경우(모든 객체가 삭제된 경우) 스키마를 삭제하려면 다음을 사용하십시오: <programlisting>
DROP SCHEMA myschema;
</programlisting>
                포함된 모든 객체를 포함하여 스키마를 삭제하려면 다음을 사용하십시오: <programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting> 이 기능의 일반적인
                메커니즘에 대한 설명은 <xref linkend="ddl-depend" />를 참조하십시오. </para>

            <para> 종종 다른 사용자가 소유한 스키마를 생성하고 싶을 수 있습니다 (이는 사용자의 활동을 잘 정의된 네임스페이스로 제한하는 방법 중 하나이기
                때문입니다). 이를 위한 구문은 다음과 같습니다: <programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
                스키마 이름을 생략할 수도 있으며, 이 경우 스키마 이름은 사용자 이름과 동일하게 됩니다. 이것이 어떻게 유용한지는 <xref
                    linkend="ddl-schemas-patterns" />를 참조하십시오. </para>

            <para>
                <literal>pg_</literal>로 시작하는 스키마 이름은 시스템용으로 예약되어 있으며 사용자가 생성할 수 없습니다. </para>
        </sect2>

        <sect2 id="ddl-schemas-public">
            <title>Public 스키마</title>

            <indexterm zone="ddl-schemas-public">
                <primary>schema</primary>
                <secondary>public</secondary>
            </indexterm>

            <para> 이전 섹션에서 우리는 스키마 이름을 지정하지 않고 테이블을 생성했습니다. 기본적으로 이러한 테이블(및 기타 객체)은 자동으로 <quote>
                public</quote>이라는 스키마에 배치됩니다. 모든 새로운 데이터베이스는 이러한 스키마를 포함합니다. 따라서 다음은 동일합니다: <programlisting>
CREATE TABLE products ( ... );
</programlisting>
                그리고: <programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
            </para>
        </sect2>

        <sect2 id="ddl-schemas-path">
            <title>스키마 검색 경로</title>

            <indexterm>
                <primary>search path</primary>
            </indexterm>

            <indexterm>
                <primary>unqualified name</primary>
            </indexterm>

            <indexterm>
                <primary>name</primary>
                <secondary>unqualified</secondary>
            </indexterm>

            <para> 정규화된 이름을 작성하는 것은 번거롭고, 애플리케이션에 특정 스키마 이름을 하드코딩하는 것은 대체로 좋지 않습니다. 따라서 테이블은 종종 테이블
                이름만으로 구성된 <firstterm>비정규화된 이름</firstterm>으로 참조됩니다. 시스템은 <firstterm>검색 경로</firstterm>를
                따라 어떤 테이블을 의미하는지 결정하는데, 이는 찾아볼 스키마의 목록입니다. 검색 경로에서 첫 번째로 일치하는 테이블이 원하는 테이블로 간주됩니다.
                검색 경로에서 일치하는 것이 없으면, 데이터베이스의 다른 스키마에 일치하는 테이블 이름이 존재하더라도 오류가 보고됩니다. </para>

            <para> 서로 다른 스키마에 동일한 이름의 객체를 생성할 수 있는 기능은 매번 정확히 동일한 객체를 참조하는 쿼리를 작성하는 것을 복잡하게 만듭니다. 또한
                사용자가 악의적으로 또는 실수로 다른 사용자의 쿼리 동작을 변경할 수 있는 가능성을 열어줍니다. 쿼리에서 비정규화된 이름이 널리 사용되고 <productname>
                PostgreSQL</productname> 내부에서 사용되기 때문에, <varname>search_path</varname>에 스키마를 추가하는 것은
                사실상 해당 스키마에 대한 <literal>CREATE</literal> 권한을 가진 모든 사용자를 신뢰하는 것입니다. 일반적인 쿼리를 실행할 때,
                검색 경로의 스키마에 객체를 생성할 수 있는 악의적인 사용자는 마치 당신이 실행한 것처럼 임의의 SQL 함수를 실행할 수 있게 됩니다. </para>

            <indexterm>
                <primary>schema</primary>
                <secondary>current</secondary>
            </indexterm>

            <para> 검색 경로에서 첫 번째로 명명된 스키마를 현재 스키마라고 합니다. 검색에서 첫 번째로 찾는 스키마일 뿐만 아니라, <command>CREATE
                TABLE</command> 명령에서 스키마 이름을 지정하지 않은 경우 새 테이블이 생성될 스키마이기도 합니다. </para>

            <indexterm>
                <primary><varname>search_path</varname> configuration parameter</primary>
            </indexterm>

            <para> 현재 검색 경로를 보려면 다음 명령을 사용하십시오: <programlisting>
SHOW search_path;
</programlisting> 기본 설정에서는 다음과 같이
                반환됩니다: <screen>
 search_path
--------------
 "$user", public
</screen> 첫 번째 요소는 현재 사용자와 동일한 이름의 스키마를 검색해야 함을 지정합니다. 그러한 스키마가 존재하지
                않으면 해당 항목은 무시됩니다. 두 번째 요소는 이미 살펴본 public 스키마를 참조합니다. </para>

            <para>
                검색 경로에서 존재하는 첫 번째 스키마가 새로운 객체를 생성하는 기본 위치입니다.
                이것이 기본적으로 객체가 public 스키마에 생성되는 이유입니다. 객체가
                스키마 정규화 없이 다른 맥락에서 참조될 때(테이블 수정, 데이터 수정 또는
                쿼리 명령) 일치하는 객체가 발견될 때까지 검색 경로가 순회됩니다.
                따라서 기본 구성에서는 비정규화된 접근은 다시 public 스키마만을
                참조할 수 있습니다.
            </para>

            <para> 새로운 스키마를 경로에 넣으려면 다음을 사용합니다: <programlisting>
SET search_path TO myschema,public;
</programlisting> (여기서는 <literal>
                $user</literal>를 즉시 필요로 하지 않기 때문에 생략했습니다.) 그리고 나서 스키마 정규화 없이 테이블에 접근할 수 있습니다: <programlisting>
DROP TABLE mytable;
</programlisting>
                또한 <literal>myschema</literal>가 경로의 첫 번째 요소이므로, 새로운 객체는 기본적으로 여기에 생성됩니다. </para>

            <para> 다음과 같이 작성할 수도 있습니다: <programlisting>
SET search_path TO myschema;
</programlisting> 이제 명시적인 정규화 없이는 public 스키마에
                더 이상 접근할 수 없습니다. public 스키마는 기본적으로 존재한다는 점 외에는 특별한 것이 없습니다. 이 스키마도 삭제할 수 있습니다. </para>

            <para> 스키마 검색 경로를 조작하는 다른 방법은 <xref linkend="functions-info" />를 참조하십시오. </para>

            <para> 검색 경로는 테이블 이름에 대해 작동하는 것과 동일한 방식으로 데이터 타입 이름, 함수 이름, 연산자 이름에 대해서도 작동합니다. 데이터 타입과
                함수 이름은 테이블 이름과 정확히 동일한 방식으로 정규화될 수 있습니다. 표현식에서 정규화된 연산자 이름을 작성해야 하는 경우, 다음과 같은 특별한
                규정이 있습니다: <synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
                이는 구문적 모호성을 피하기 위해 필요합니다. 예를 들면: <programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting> 실제로는 보통 이렇게 못생긴
                것을 작성하지 않아도 되도록 연산자에 대해 검색 경로를 사용합니다. </para>
        </sect2>

        <sect2 id="ddl-schemas-priv">
            <title>스키마와 권한</title>

            <indexterm zone="ddl-schemas-priv">
                <primary>privilege</primary>
                <secondary sortas="schemas">for schemas</secondary>
            </indexterm>

            <para> 기본적으로 사용자는 자신이 소유하지 않은 스키마의 객체에 접근할 수 없습니다. 이를 허용하려면 스키마의 소유자가 스키마에 대한 <literal>
                USAGE</literal> 권한을 부여해야 합니다. 기본적으로 모든 사용자는 <literal>public</literal> 스키마에 대해 해당 권한을
                가지고 있습니다. 사용자가 스키마의 객체를 사용할 수 있도록 하려면 객체에 따라 추가 권한을 부여해야 할 수 있습니다. </para>

            <para> 사용자는 다른 사람의 스키마에 객체를 생성하는 것도 허용될 수 있습니다. 이를 허용하려면 스키마에 대한 <literal>CREATE</literal>
                권한을 부여해야 합니다. <productname>PostgreSQL</productname> 14 이전 버전에서 업그레이드된 데이터베이스에서는 모든
                사용자가 <literal>public</literal> 스키마에 대해 해당 권한을 가지고 있습니다. 일부 <link
                    linkend="ddl-schemas-patterns">사용 패턴</link>에서는 이 권한을 취소하는 것이 필요합니다: <programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
                (첫 번째 <quote>public</quote>은 스키마이고, 두 번째 <quote>public</quote>은 <quote>모든 사용자</quote>를
                의미합니다. 첫 번째는 식별자이고 두 번째는 키워드이기 때문에 대소문자가 다릅니다; <xref
                    linkend="sql-syntax-identifiers" />의 지침을 상기하십시오.) </para>
        </sect2>

        <sect2 id="ddl-schemas-catalog">
            <title>시스템 카탈로그 스키마</title>

            <indexterm zone="ddl-schemas-catalog">
                <primary>system catalog</primary>
                <secondary>schema</secondary>
            </indexterm>

            <para>
                <literal>public</literal>과 사용자가 생성한 스키마 외에도, 각 데이터베이스는 시스템 테이블과 모든 내장 데이터 타입, 함수,
                연산자를 포함하는 <literal>pg_catalog</literal> 스키마를 포함합니다. <literal>pg_catalog</literal>는
                항상 실질적으로 검색 경로의 일부입니다. 경로에서 명시적으로 지정되지 않은 경우에도 경로의 스키마를 검색하기 <emphasis>전에</emphasis>
                암시적으로 검색됩니다. 이는 내장된 이름을 항상 찾을 수 있도록 보장합니다. 하지만, 사용자 정의 이름이 내장된 이름을 재정의하도록 하려면 <literal>
                pg_catalog</literal>를 검색 경로의 끝에 명시적으로 배치할 수 있습니다. </para>

            <para> 시스템 테이블 이름이 <literal>pg_</literal>로 시작하므로, 향후 버전에서 당신의 테이블과 동일한 이름의 시스템 테이블이 정의되어
                충돌이 발생하는 것을 방지하기 위해 이러한 이름을 사용하지 않는 것이 좋습니다. (기본 검색 경로에서는 당신의 테이블 이름에 대한 비정규화된 참조가
                시스템 테이블로 해석될 것입니다.) 시스템 테이블은 계속해서 <literal>pg_</literal>로 시작하는 이름을 사용할 것이므로, 사용자가 <literal>
                pg_</literal> 접두사를 피하는 한 비정규화된 사용자 테이블 이름과 충돌하지 않을 것입니다. </para>
        </sect2>

        <sect2 id="ddl-schemas-patterns">
            <title>사용 패턴</title>

            <para> 스키마는 데이터를 다양한 방식으로 구성하는 데 사용될 수 있습니다. <firstterm>안전한 스키마 사용 패턴</firstterm>은 신뢰할 수
                없는 사용자가 다른 사용자의 쿼리 동작을 변경하는 것을 방지합니다. 데이터베이스가 안전한 스키마 사용 패턴을 사용하지 않는 경우, 해당 데이터베이스를
                안전하게 쿼리하고자 하는 사용자는 각 세션 시작 시 보호 조치를 취해야 합니다. 구체적으로, 각 세션을 시작할 때 <varname>search_path</varname>를
                빈 문자열로 설정하거나 수퍼유저가 아닌 사용자가 쓸 수 있는 스키마를 <varname>search_path</varname>에서 제거해야 합니다. 기본
                구성으로 쉽게 지원되는 몇 가지 사용 패턴이 있습니다: <itemizedlist>
                    <listitem>
                        <para> 일반 사용자를 사용자 전용 스키마로 제한합니다. 이 패턴을 구현하려면, 먼저 어떤 스키마도 public <literal>
                CREATE</literal> 권한을 가지지 않도록 합니다. 그런 다음, 임시 객체가 아닌 객체를 생성해야 하는 모든 사용자에 대해, 해당 사용자와
                동일한 이름의 스키마를 생성합니다. 예를 들어 <literal>CREATE SCHEMA alice AUTHORIZATION alice</literal>와
                같이 합니다. (기본 검색 경로가 사용자 이름으로 해석되는 <literal>$user</literal>로 시작한다는 것을 기억하십시오. 따라서 각
                사용자가 별도의 스키마를 가지고 있다면, 기본적으로 자신의 스키마에 접근합니다.) 이 패턴은 신뢰할 수 없는 사용자가 데이터베이스 소유자이거나 관련
                역할에 대한 <literal>ADMIN OPTION</literal>이 부여된 경우를 제외하고는 안전한 스키마 사용 패턴입니다. </para>

                        <para>
                            <productname>PostgreSQL</productname> 15 이상에서는 기본 구성이 이 사용 패턴을 지원합니다. 이전
                버전이나 이전 버전에서 업그레이드된 데이터베이스를 사용하는 경우, <literal>public</literal> 스키마에서 public <literal>
                CREATE</literal> 권한을 제거해야 합니다(<literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>
                실행). 그런 다음 <literal>public</literal> 스키마에서 <literal>pg_catalog</literal> 스키마의 객체와
                유사한 이름을 가진 객체가 있는지 감사하는 것을 고려하십시오. </para>
                    </listitem>

                    <listitem>
                        <para>
                            <link linkend="config-setting-configuration-file">
                                <filename>postgresql.conf</filename>
                            </link>를
                수정하거나 <literal>ALTER ROLE ALL SET search_path = "$user"</literal>를 실행하여 기본 검색 경로에서
                public 스키마를 제거합니다. 그런 다음 public 스키마에서 생성할 수 있는 권한을 부여합니다. 정규화된 이름만이 public 스키마 객체를
                선택할 것입니다. 정규화된 테이블 참조는 괜찮지만, public 스키마의 함수 호출은 <link linkend="typeconv-func">안전하지
                않거나
                                신뢰할 수 없을</link> 것입니다. public 스키마에서 함수나 확장을 생성하는 경우 첫 번째 패턴을 대신
                사용하십시오. 그렇지 않으면, 첫 번째 패턴과 마찬가지로, 신뢰할 수 없는 사용자가 데이터베이스 소유자이거나 관련 역할에 대한 <literal>ADMIN
                OPTION</literal>이 부여된 경우를 제외하고는 안전합니다. </para>
                    </listitem>

                    <listitem>
                        <para> 기본 검색 경로를 유지하고, public 스키마에서 생성할 수 있는 권한을 부여합니다. 모든 사용자가 암시적으로 public
                스키마에 접근합니다. 이는 스키마를 전혀 사용할 수 없는 상황을 시뮬레이션하여, 스키마를 인식하지 못하는 세계에서 원활한 전환을 제공합니다. 하지만,
                이는 결코 안전한 패턴이 아닙니다. 데이터베이스에 단일 사용자가 있거나 서로 신뢰하는 소수의 사용자가 있는 경우에만 허용됩니다. <productname>
                PostgreSQL</productname> 14 이전 버전에서 업그레이드된 데이터베이스에서는 이것이 기본값입니다. </para>
                    </listitem>
                </itemizedlist>
            </para>

            <para>
                어떤 패턴이든, 공유 애플리케이션(모든 사람이 사용할 테이블, 서드파티가
                제공하는 추가 함수 등)을 설치하려면 별도의 스키마에 넣으십시오. 다른
                사용자가 접근할 수 있도록 적절한 권한을 부여하는 것을 잊지 마십시오.
                사용자는 스키마 이름으로 이러한 추가 객체를 정규화하여 참조하거나,
                원하는 대로 추가 스키마를 검색 경로에 넣을 수 있습니다.
            </para>
        </sect2>

        <sect2 id="ddl-schemas-portability">
            <title>이식성</title>

            <para> SQL 표준에서는 동일한 스키마 내의 객체가 서로 다른 사용자에 의해 소유되는 개념이 존재하지 않습니다. 더욱이, 일부 구현에서는 소유자와 다른
                이름을 가진 스키마를 생성하는 것을 허용하지 않습니다. 실제로, 표준에서 지정한 기본 스키마 지원만을 구현하는 데이터베이스 시스템에서는 스키마와
                사용자의 개념이 거의 동일합니다. 따라서 많은 사용자들은 정규화된 이름이 실제로 <literal><replaceable>user_name</replaceable>
                .<replaceable>table_name</replaceable></literal>으로 구성된다고 생각합니다. 이는 모든 사용자에 대해 사용자별
                스키마를 생성하는 경우 <productname>PostgreSQL</productname>이 실제로 동작하는 방식입니다. </para>

            <para> 또한, SQL 표준에는 <literal>public</literal> 스키마의 개념이 없습니다. 표준에 대한 최대한의 준수를 위해서는 <literal>
                public</literal> 스키마를 사용하지 않아야 합니다. </para>

            <para>
                물론, 일부 SQL 데이터베이스 시스템은 스키마를 전혀 구현하지 않거나,
                (제한적일 수 있는) 데이터베이스 간 접근을 허용하여 네임스페이스 지원을
                제공할 수 있습니다. 이러한 시스템에서 작업해야 하는 경우, 스키마를 전혀
                사용하지 않는 것이 최대한의 이식성을 달성하는 방법일 것입니다.
            </para>
        </sect2>
    </sect1>

    <sect1 id="ddl-inherit">
        <title>상속</title>

        <indexterm>
            <primary>inheritance</primary>
        </indexterm>

        <indexterm>
            <primary>table</primary>
            <secondary>inheritance</secondary>
        </indexterm>

        <para>
            <productname>PostgreSQL</productname>은 데이터베이스 설계자에게 유용한 도구가 될 수 있는 테이블 상속을 구현합니다.
            (SQL:1999 이후 버전에서는 여기서 설명하는 기능과 많은 면에서 다른 타입 상속 기능을 정의합니다.) </para>

        <para> 예제로 시작해보겠습니다: 도시에 대한 데이터 모델을 만들려고 한다고 가정해보겠습니다. 각 주에는 많은 도시가 있지만, 수도는 하나뿐입니다. 우리는 특정
            주의 수도를 빠르게 검색할 수 있기를 원합니다. 이는 주 수도를 위한 테이블 하나와 수도가 아닌 도시를 위한 테이블 하나를 만들어 해결할 수 있습니다.
            하지만, 수도인지 아닌지에 관계없이 도시에 대한 데이터를 요청하려고 할 때는 어떻게 될까요? 상속 기능이 이 문제를 해결하는 데 도움이 될 수 있습니다. <structname>
            capitals</structname> 테이블이 <structname>cities</structname>에서 상속받도록 정의합니다: <programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -- 피트 단위
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>
            이 경우, <structname>capitals</structname> 테이블은 부모 테이블인 <structname>cities</structname>의 모든
            컬럼을 <firstterm>상속</firstterm>합니다. 주 수도는 또한 그들의 주를 보여주는 추가 컬럼인 <structfield>state</structfield>를
            가지고 있습니다. </para>

        <para>
            <productname>PostgreSQL</productname>에서는 테이블이 0개 이상의 다른 테이블을 상속할 수 있으며, 쿼리는 테이블의 모든 행을
            참조하거나 테이블과 그 자손 테이블의 모든 행을 참조할 수 있습니다. 후자가 기본 동작입니다. 예를 들어, 다음 쿼리는 주 수도를 포함하여 고도가 500피트가
            넘는 모든 도시의 이름을 찾습니다: <programlisting>
SELECT name, elevation
    FROM cities
    WHERE elevation &gt; 500;
</programlisting>

   <productname>PostgreSQL</productname>
            튜토리얼의 샘플 데이터를 기준으로 (<xref linkend="tutorial-sql-intro" /> 참조), 다음과 같이 반환됩니다: <programlisting>
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
</programlisting>
        </para>

        <para> 반면에, 다음 쿼리는 고도가 500피트가 넘는 주 수도가 아닌 모든 도시를 찾습니다: <programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;

   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
</programlisting>
        </para>

        <para> 여기서 <literal>ONLY</literal> 키워드는 쿼리가 상속 계층에서 <structname>cities</structname> 아래에 있는
            테이블이 아닌 <structname>cities</structname>에만 적용되어야 함을 나타냅니다. 이미 논의한 많은 명령어 &mdash; <command>
            SELECT</command>, <command>UPDATE</command>, <command>DELETE</command> &mdash;가 <literal>
            ONLY</literal> 키워드를 지원합니다. </para>

        <para> 자손 테이블이 포함됨을 명시적으로 지정하기 위해 테이블 이름 뒤에 <literal>*</literal>를 붙여 쓸 수도 있습니다: <programlisting>
SELECT name, elevation
    FROM cities*
    WHERE elevation &gt; 500;
</programlisting>

   <literal>
            *</literal>를 쓰는 것은 필수가 아닙니다. 이 동작이 항상 기본값이기 때문입니다. 하지만, 기본값을 변경할 수 있었던 이전 릴리스와의 호환성을 위해
            이 구문은 여전히 지원됩니다. </para>

        <para> 어떤 경우에는 특정 행이 어떤 테이블에서 왔는지 알고 싶을 수 있습니다. 각 테이블에는 원본 테이블을 알려줄 수 있는 <structfield>
            tableoid</structfield>라는 시스템 컬럼이 있습니다: <programlisting>
SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting> 이는 다음을 반환합니다: <programlisting>
 tableoid |   name    | elevation
----------+-----------+-----------
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845
</programlisting>
            (이 예제를 재현해보면 아마도 다른 숫자의 OID를 얻게 될 것입니다.) <structname>pg_class</structname>와 조인하면 실제 테이블
            이름을 볼 수 있습니다: <programlisting>
SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation &gt; 500 AND c.tableoid = p.oid;
</programlisting> 이는 다음을 반환합니다: <programlisting>
 relname  |   name    | elevation
----------+-----------+-----------
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845
</programlisting>
        </para>

        <para> 같은 효과를 얻는 다른 방법은 테이블 OID를 상징적으로 출력할 <type>regclass</type> 별칭 타입을 사용하는 것입니다: <programlisting>
SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>
        </para>

        <para> 상속은 <command>INSERT</command>나 <command>COPY</command> 명령의 데이터를 상속 계층의 다른 테이블로 자동으로
            전파하지 않습니다. 우리의 예제에서 다음 <command>INSERT</command> 문은 실패할 것입니다: <programlisting>
INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
            데이터가 어떻게든 <structname>capitals</structname> 테이블로 라우팅되기를 기대할 수 있지만, 이는 발생하지 않습니다: <command>
            INSERT</command>는 항상 정확히 지정된 테이블에만 삽입합니다. 일부 경우에는 규칙을 사용하여 삽입을 리디렉션할 수 있습니다(참조 <xref
                linkend="rules" />). 하지만 그것은 위의 경우에 도움이 되지 않습니다. <structname>cities</structname>
            테이블에 <structfield>state</structfield> 컬럼이 없기 때문에 규칙이 적용되기 전에 명령이 거부될 것이기 때문입니다. </para>

        <para> 부모 테이블의 모든 검사 제약 조건과 not-null 제약 조건은 <literal>NO INHERIT</literal> 절로 명시적으로 지정하지 않는 한
            자동으로 자식에게 상속됩니다. 다른 유형의 제약 조건(unique, primary key, foreign key 제약 조건)은 상속되지 않습니다. </para>

        <para> 테이블은 둘 이상의 부모 테이블을 상속할 수 있으며, 이 경우 부모 테이블들이 정의한 컬럼의 합집합을 가집니다. 자식 테이블의 정의에서 선언된 모든
            컬럼이 여기에 추가됩니다. 만약 같은 컬럼 이름이 여러 부모 테이블에 나타나거나, 부모 테이블과 자식의 정의 모두에 나타나면, 이러한 컬럼들은 <quote>
            병합</quote>되어 자식 테이블에는 하나의 컬럼만 존재하게 됩니다. 병합되려면 컬럼들이 같은 데이터 타입을 가져야 하며, 그렇지 않으면 오류가 발생합니다.
            상속 가능한 검사 제약 조건과 not-null 제약 조건도 비슷한 방식으로 병합됩니다. 예를 들어, 병합된 컬럼은 원본 컬럼 정의 중 하나라도
            not-null로 표시되어 있다면 not-null로 표시됩니다. 검사 제약 조건은 같은 이름을 가진 경우 병합되며, 조건이 다르면 병합이 실패합니다. </para>

        <para> 테이블 상속은 일반적으로 자식 테이블이 생성될 때 <link linkend="sql-createtable">
                <command>CREATE TABLE</command>
            </link> 문의 <literal>INHERITS</literal> 절을
            사용하여 설정됩니다. 또는 이미 호환되는 방식으로 정의된 테이블에 <link linkend="sql-altertable">
                <command>ALTER TABLE</command>
            </link>의 <literal>INHERIT</literal> 변형을
            사용하여 새로운 부모 관계를 추가할 수 있습니다. 이를 위해서는 새로운 자식 테이블이 이미 부모의 컬럼과 같은 이름과 타입을 가진 컬럼을 포함하고 있어야
            합니다. 또한 부모와 같은 이름과 검사 표현식을 가진 검사 제약 조건도 포함해야 합니다. 마찬가지로 <command>ALTER TABLE</command>의 <literal>NO
            INHERIT</literal> 변형을 사용하여 자식으로부터 상속 링크를 제거할 수 있습니다. 이런 식으로 상속 링크를 동적으로 추가하고 제거하는 것은 상속
            관계가 테이블 파티셔닝에 사용될 때 유용할 수 있습니다(참조 <xref linkend="ddl-partitioning" />). </para>

        <para> 나중에 새로운 자식이 될 호환되는 테이블을 만드는 편리한 방법 중 하나는 <command>CREATE TABLE</command>에서 <literal>
            LIKE</literal> 절을 사용하는 것입니다. 이는 소스 테이블과 동일한 컬럼을 가진 새로운 테이블을 만듭니다. 소스 테이블에 <literal>CHECK</literal>
            제약 조건이 정의되어 있다면, 새로운 자식이 호환되는 것으로 간주되기 위해서는 부모와 일치하는 제약 조건을 가져야 하므로 <literal>LIKE</literal>
            의 <literal>INCLUDING CONSTRAINTS</literal> 옵션을 지정해야 합니다. </para>

        <para> 자식이 하나라도 남아있다면 부모 테이블을 삭제할 수 없습니다. 또한 부모 테이블로부터 상속된 자식 테이블의 컬럼이나 검사 제약 조건을 삭제하거나 변경할
            수 없습니다. 테이블과 그 모든 자손을 제거하고 싶다면, 쉬운 방법은 <literal>CASCADE</literal> 옵션과 함께 부모 테이블을 삭제하는
            것입니다 (참조 <xref linkend="ddl-depend" />). </para>

        <para>
            <command>ALTER TABLE</command>은 컬럼 데이터 정의와 검사 제약 조건의 모든 변경 사항을 상속 계층 아래로 전파합니다. 마찬가지로,
            다른 테이블이 의존하는 컬럼을 삭제하는 것은 <literal>CASCADE</literal> 옵션을 사용할 때만 가능합니다. <command>ALTER
            TABLE</command>은 <command>CREATE TABLE</command> 동안 적용되는 것과 동일한 중복 컬럼 병합 및 거부 규칙을 따릅니다. </para>

        <para> 상속된 쿼리는 부모 테이블에서만 접근 권한 검사를 수행합니다. 따라서, 예를 들어 <structname>cities</structname> 테이블에 <literal>
            UPDATE</literal> 권한을 부여하면 <structname>cities</structname>를 통해 접근할 때 <structname>capitals</structname>
            테이블의 행도 업데이트할 수 있다는 것을 의미합니다. 이는 데이터가 (또한) 부모 테이블에 있다는 외관을 유지합니다. 하지만 추가 권한 부여 없이는 <structname>
            capitals</structname> 테이블을 직접 업데이트할 수는 없습니다. 비슷한 방식으로, 부모 테이블의 행 보안 정책(참조 <xref
                linkend="ddl-rowsecurity" />)은 상속된 쿼리 동안 자식 테이블에서 오는 행에 적용됩니다. 자식 테이블의 정책은 있다면, 쿼리에서
            해당 테이블이 명시적으로 이름이 지정된 경우에만 적용됩니다; 그리고 이 경우, 부모에 연결된 모든 정책은 무시됩니다. </para>

        <para> 외래 테이블(참조 <xref linkend="ddl-foreign-data" />)도 일반 테이블처럼 부모 또는 자식 테이블로서 상속 계층의 일부가 될
            수 있습니다. 외래 테이블이 상속 계층의 일부인 경우 외래 테이블이 지원하지 않는 모든 작업은 전체 계층에서도 지원되지 않습니다. </para>

        <sect2 id="ddl-inherit-caveats">
            <title>주의사항</title>

            <para> 모든 SQL 명령이 상속 계층에서 작동할 수 있는 것은 아닙니다. 데이터 조회, 데이터 수정, 또는 스키마 수정에 사용되는 명령(예: <literal>
                SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>ALTER
                TABLE</literal>의 대부분의 변형, 하지만 <literal>INSERT</literal>나 <literal>ALTER TABLE ...
                RENAME</literal>은 제외)은 일반적으로 기본적으로 자식 테이블을 포함하며 이들을 제외하기 위한 <literal>ONLY</literal>
                표기법을 지원합니다. 데이터베이스 유지보수와 튜닝을 수행하는 대부분의 명령(예: <literal>REINDEX</literal>)은 개별 물리적
                테이블에서만 작동하며 상속 계층을 재귀적으로 처리하는 것을 지원하지 않습니다. 하지만 <literal>VACUUM</literal>과 <literal>
                ANALYZE</literal> 명령은 기본적으로 자식 테이블을 포함하며 이들을 제외할 수 있는 <literal>ONLY</literal> 표기법을
                지원합니다. 각 개별 명령의 해당 동작은 참조 페이지에 문서화되어 있습니다(<xref linkend="sql-commands" />). </para>

            <para> 상속 기능의 심각한 제한 사항은 인덱스(고유 제약 조건 포함)와 외래 키 제약 조건이 단일 테이블에만 적용되고 그들의 상속 자식에는 적용되지
                않는다는 것입니다. 이는 외래 키 제약 조건의 참조하는 쪽과 참조되는 쪽 모두에 해당됩니다. 따라서, 위의 예제에서: <itemizedlist>
                    <listitem>
                        <para>
                            <structname>cities</structname>.<structfield>name</structfield>을 <literal>
                UNIQUE</literal>나 <literal>PRIMARY KEY</literal>로 선언하더라도, 이는 <structname>capitals</structname>
                테이블이 <structname>cities</structname>의 행과 중복되는 이름을 가진 행을 가지는 것을 막지 못합니다. 그리고 이러한 중복
                행들은 기본적으로 <structname>cities</structname>에서의 쿼리에 나타날 것입니다. 실제로, 기본적으로 <structname>
                capitals</structname>는 전혀 고유 제약 조건을 가지지 않아서 같은 이름을 가진 여러 행을 포함할 수 있습니다. <structname>
                capitals</structname>에 고유 제약 조건을 추가할 수 있지만, 이는 <structname>cities</structname>와 비교했을
                때의 중복을 방지하지는 못합니다. </para>
                    </listitem>

                    <listitem>
                        <para> 마찬가지로, <structname>cities</structname>.<structfield>name</structfield>이
                다른 테이블을 <literal>REFERENCES</literal>하도록 지정하더라도, 이 제약 조건은 자동으로 <structname>capitals</structname>로
                전파되지 않습니다. 이 경우에는 수동으로 동일한 <literal>REFERENCES</literal> 제약 조건을 <structname>capitals</structname>에
                추가하여 해결할 수 있습니다. </para>
                    </listitem>

                    <listitem>
                        <para> 다른 테이블의 컬럼이 <literal>REFERENCES cities(name)</literal>를 지정하면 다른 테이블이
                도시 이름은 포함할 수 있지만 수도 이름은 포함할 수 없게 됩니다. 이 경우에 대한 좋은 해결책은 없습니다. </para>
                    </listitem>
                </itemizedlist>
                상속 계층에 대해 구현되지 않은 일부 기능은 선언적 파티셔닝에 대해 구현되어 있습니다. 레거시 상속을 사용한 파티셔닝이 애플리케이션에 유용한지 결정할
                때는 상당한 주의가 필요합니다. </para>

        </sect2>
    </sect1>

    <sect1 id="ddl-partitioning">
        <title>테이블 파티셔닝</title>

        <indexterm>
            <primary>partitioning</primary>
        </indexterm>

        <indexterm>
            <primary>table</primary>
            <secondary>partitioning</secondary>
        </indexterm>

        <indexterm>
            <primary>partitioned table</primary>
        </indexterm>

        <para>
            <productname>PostgreSQL</productname>은 기본적인 테이블 파티셔닝을 지원합니다. 이 섹션에서는 데이터베이스 설계의 일부로
            파티셔닝을 구현하는 이유와 방법을 설명합니다. </para>

        <sect2 id="ddl-partitioning-overview">
            <title>개요</title>

            <para> 파티셔닝은 논리적으로 하나의 큰 테이블을 더 작은 물리적 조각으로 나누는 것을 말합니다. 파티셔닝은 여러 이점을 제공할 수 있습니다: <itemizedlist>
                    <listitem>
                        <para>
                            특정 상황, 특히 테이블의 자주 접근되는 행의 대부분이 단일 파티션이나
                            소수의 파티션에 있을 때 쿼리 성능을 극적으로 향상시킬 수 있습니다.
                            파티셔닝은 효과적으로 인덱스의 상위 트리 레벨을 대체하여, 자주 사용되는
                            인덱스 부분이 메모리에 맞을 가능성을 높입니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            쿼리나 업데이트가 단일 파티션의 큰 비율에 접근할 때, 전체 테이블에
                            산재된 무작위 접근 읽기가 필요한 인덱스를 사용하는 대신 해당 파티션의
                            순차 스캔을 사용하여 성능을 향상시킬 수 있습니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para> 사용 패턴이 파티셔닝 설계에서 고려되었다면, 파티션을 추가하거나 제거하여 대량 로드와 삭제를 수행할 수 있습니다. <command>DROP
                TABLE</command>을 사용하여 개별 파티션을 삭제하거나 <command>ALTER TABLE DETACH
                                PARTITION</command>을 수행하는 것이 대량 작업보다 훨씬 빠릅니다. 이러한 명령은 또한 대량 <command>
                DELETE</command>로 인한 <command>VACUUM</command> 오버헤드를 완전히 피합니다. </para>
                    </listitem>

                    <listitem>
                        <para>
                            거의 사용되지 않는 데이터를 더 저렴하고 느린 저장 매체로 마이그레이션할 수 있습니다.
                        </para>
                    </listitem>
                </itemizedlist>
                이러한 이점은 일반적으로 테이블이 매우 클 때만 가치가 있습니다. 테이블이 파티셔닝의 혜택을 받을 수 있는 정확한 시점은 애플리케이션에 따라 다르지만,
                경험적 규칙으로는 테이블 크기가 데이터베이스 서버의 물리적 메모리를 초과해야 합니다. </para>

            <para>
                <productname>PostgreSQL</productname>은 다음과 같은 형태의 파티셔닝에 대한 내장 지원을 제공합니다: <variablelist>
                    <varlistentry id="ddl-partitioning-overview-range">
                        <term>범위 파티셔닝</term>

                        <listitem>
                            <para> 테이블이 키 컬럼 또는 컬럼 집합에 의해 정의된 <quote>범위</quote>로 파티션되며, 서로 다른 파티션에
                할당된 값의 범위 간에 중복이 없습니다. 예를 들어, 날짜 범위로 파티션하거나 특정 비즈니스 객체의 식별자 범위로 파티션할 수 있습니다. 각 범위의
                경계는 하한에서는 포함되고 상한에서는 제외되는 것으로 이해됩니다. 예를 들어, 한 파티션의 범위가 <literal>1</literal>부터 <literal>
                10</literal>까지이고 다음 파티션의 범위가 <literal>10</literal>부터 <literal>20</literal>까지라면, 값 <literal>
                10</literal>은 첫 번째가 아닌 두 번째 파티션에 속합니다. </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry id="ddl-partitioning-overview-list">
                        <term>리스트 파티셔닝</term>

                        <listitem>
                            <para>
                                각 파티션에 어떤 키 값이 나타나는지를 명시적으로 나열하여 테이블을 파티션합니다.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry id="ddl-partitioning-overview-hash">
                        <term>해시 파티셔닝</term>

                        <listitem>
                            <para>
                                각 파티션에 대한 모듈러스와 나머지를 지정하여 테이블을 파티션합니다.
                                각 파티션은 파티션 키의 해시 값을 지정된 모듈러스로 나눈 나머지가
                                지정된 값과 일치하는 행들을 보관합니다.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                애플리케이션이 위에 나열되지 않은 다른 형태의 파티셔닝을 사용해야 하는 경우, 상속과 <literal>UNION ALL</literal> 뷰와 같은
                대체 방법을 대신 사용할 수 있습니다. 이러한 방법들은 유연성을 제공하지만 내장된 선언적 파티셔닝의 일부 성능 이점을 가지지 않습니다. </para>
        </sect2>

        <sect2 id="ddl-partitioning-declarative">
            <title>선언적 파티셔닝</title>

            <para>
                <productname>PostgreSQL</productname>은 테이블이 파티션으로 나누어진다고 선언할 수 있게 합니다. 나누어진 테이블을 <firstterm>파티션된
                테이블</firstterm>이라고 합니다. 선언에는 위에서 설명한 <firstterm>파티셔닝 방법</firstterm>과 함께 <firstterm>파티션
                키</firstterm>로 사용될 컬럼이나 표현식의 목록이 포함됩니다. </para>

            <para> 파티션된 테이블 자체는 자체 저장소가 없는 <quote>가상</quote> 테이블입니다. 대신, 저장소는 파티션된 테이블과 연관된 일반적인
                테이블인 <firstterm>파티션</firstterm>에 속합니다. 각 파티션은 <firstterm>파티션 경계</firstterm>에 의해 정의된
                대로 데이터의 부분집합을 저장합니다. 파티션된 테이블에 삽입되는 모든 행은 파티션 키 컬럼의 값을 기반으로 적절한 파티션으로 라우팅됩니다. 행의 파티션
                키를 업데이트하면 더 이상 원래 파티션의 파티션 경계를 만족하지 않는 경우 다른 파티션으로 이동됩니다. </para>

            <para> 파티션 자체가 파티션된 테이블로 정의될 수 있어 <firstterm>하위 파티셔닝</firstterm>이 가능합니다. 모든 파티션은 파티션된
                부모와 동일한 컬럼을 가져야 하지만, 파티션은 다른 파티션과 구별되는 자체 인덱스, 제약 조건 및 기본값을 가질 수 있습니다. 파티션된 테이블과 파티션
                생성에 대한 자세한 내용은 <xref linkend="sql-createtable" />를 참조하십시오. </para>

            <para> 일반 테이블을 파티션된 테이블로 변환하거나 그 반대로 변환하는 것은 불가능합니다. 하지만 기존의 일반 테이블이나 파티션된 테이블을 파티션된
                테이블의 파티션으로 추가하거나, 파티션을 파티션된 테이블에서 제거하여 독립 테이블로 만드는 것은 가능합니다; 이는 많은 유지보수 프로세스를 단순화하고
                가속화할 수 있습니다. <command>ATTACH PARTITION</command>과 <command>DETACH PARTITION</command>
                하위 명령에 대해 자세히 알아보려면 <xref linkend="sql-altertable" />을 참조하십시오. </para>

            <para> 파티션은 <link linkend="ddl-foreign-data">외래 테이블</link>일 수도 있지만, 외래 테이블의 내용이 파티셔닝 규칙을
                만족하는지 확인하는 것은 사용자의 책임이기 때문에 상당한 주의가 필요합니다. 다른 제한 사항들도 있습니다. 자세한 내용은 <xref
                    linkend="sql-createforeigntable" />을 참조하십시오. </para>

            <sect3 id="ddl-partitioning-declarative-example">
                <title>예제</title>

                <para> 대규모 아이스크림 회사를 위한 데이터베이스를 구축한다고 가정해 보겠습니다. 이 회사는 매일 최고 기온과 각 지역의 아이스크림 판매량을
                    측정합니다. 개념적으로, 우리는 다음과 같은 테이블을 원합니다: <programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting> 이 테이블의 주요
                    용도가 관리자를 위한 온라인 보고서를 준비하는 것이기 때문에, 대부분의 쿼리가 지난 주, 달, 또는 분기의 데이터에만 접근할 것이라는 것을 알고
                    있습니다. 저장해야 할 오래된 데이터의 양을 줄이기 위해, 최근 3년치의 데이터만 보관하기로 결정합니다. 매월 초에 가장 오래된 달의 데이터를
                    제거할 것입니다. 이러한 상황에서 우리는 파티셔닝을 사용하여 measurements 테이블에 대한 모든 다양한 요구사항을 충족시키는 데 도움을
                    받을 수 있습니다. </para>

                <para> 이 경우에 선언적 파티셔닝을 사용하려면 다음 단계를 따르십시오: <orderedlist spacing="compact">
                        <listitem>
                            <para> 파티셔닝 방법(<literal>RANGE</literal>, 이 경우)과 파티션 키로 사용할 컬럼 목록을 포함하는 <literal>PARTITION
                    BY</literal> 절을 지정하여 <structname>measurement</structname> 테이블을 파티션된 테이블로 생성합니다. <programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                파티션을 생성합니다. 각 파티션의 정의는 부모의 파티셔닝 방법과 파티션 키에
                                해당하는 경계를 지정해야 합니다. 새 파티션의 값이 하나 이상의 기존 파티션의
                                값과 겹치도록 경계를 지정하면 오류가 발생합니다.
                            </para>

                            <para> 이렇게 생성된 파티션은 모든 면에서 일반적인 <productname>PostgreSQL</productname>
                    테이블(또는 외래 테이블)입니다. 각 파티션에 대해 테이블스페이스와 저장소 매개변수를 별도로 지정할 수 있습니다. </para>

                            <para> 우리의 예제에서는 한 번에 한 달치 데이터를 삭제한다는 요구사항에 맞추기 위해 각 파티션이 한 달치 데이터를 보관해야
                    합니다. 따라서 명령은 다음과 같을 수 있습니다: <programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting> (인접한 파티션은 범위의 상한이
                    배타적 경계로 처리되므로 경계값을 공유할 수 있습니다.) </para>

                            <para> 하위 파티셔닝을 구현하려면, 개별 파티션을 생성하는 데 사용되는 명령에서 다시 <literal>PARTITION BY</literal>
                    절을 지정하면 됩니다. 예를 들면: <programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       <structname>
                    measurement_y2006m02</structname>의 파티션을 생성한 후, <structname>measurement</structname>에
                    삽입되어 <structname>measurement_y2006m02</structname>로 매핑되는 모든 데이터 (또는 파티션 제약 조건이
                    만족되는 경우 <structname>measurement_y2006m02</structname>에 직접 삽입되는 데이터)는 <structfield>
                    peaktemp</structfield> 컬럼을 기준으로 하위 파티션 중 하나로 추가로 리디렉션됩니다. 지정된 파티션 키는 부모의 파티션 키와
                    겹칠 수 있지만, 하위 파티션의 경계를 지정할 때는 해당 파티션이 허용하는 데이터 집합이 파티션 자체의 경계가 허용하는 것의 부분집합이 되도록
                    주의해야 합니다; 시스템은 이것이 실제로 그런지 확인하려 하지 않습니다. </para>

                            <para>
                                기존 파티션 중 하나에 매핑되지 않는 데이터를 부모 테이블에 삽입하면
                                오류가 발생합니다; 적절한 파티션을 수동으로 추가해야 합니다.
                            </para>

                            <para>
                                파티션의 경계 조건을 설명하는 테이블 제약 조건을 수동으로 생성할 필요는
                                없습니다. 이러한 제약 조건은 자동으로 생성됩니다.
                            </para>
                        </listitem>

                        <listitem>
                            <para> 파티션된 테이블에 키 컬럼에 대한 인덱스와 원하는 다른 인덱스를 생성하십시오. (키 인덱스는 엄격히 말해 필요하지
                    않지만, 대부분의 시나리오에서 도움이 됩니다.) 이는 자동으로 각 파티션에 일치하는 인덱스를 생성하며, 나중에 생성하거나 연결하는 모든 파티션도
                    이러한 인덱스를 가지게 됩니다. 파티션된 테이블에 선언된 인덱스나 고유 제약 조건은 파티션된 테이블이 그런 것처럼 <quote>가상</quote>입니다:
                    실제 데이터는 개별 파티션 테이블의 자식 인덱스에 있습니다. <programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <filename>postgresql.conf</filename>에서 <xref
                                    linkend="guc-enable-partition-pruning" /> 설정 매개변수가 비활성화되어 있지 않은지
                    확인하십시오. 비활성화되어 있으면 쿼리가 원하는 대로 최적화되지 않습니다. </para>
                        </listitem>
                    </orderedlist>
                </para>

                <para>
                    위의 예제에서는 매월 새로운 파티션을 생성하게 되므로, 필요한 DDL을 자동으로
                    생성하는 스크립트를 작성하는 것이 현명할 수 있습니다.
                </para>
            </sect3>

            <sect3 id="ddl-partitioning-declarative-maintenance">
                <title>파티션 유지보수</title>

                <para>
                    일반적으로 테이블을 처음 정의할 때 설정된 파티션 집합이 정적으로 유지되는
                    것은 의도되지 않습니다. 오래된 데이터를 보관하는 파티션을 제거하고 새로운
                    데이터를 위한 새 파티션을 주기적으로 추가하고자 하는 것이 일반적입니다.
                    파티셔닝의 가장 중요한 장점 중 하나는 바로 대량의 데이터를 물리적으로
                    이동시키는 대신 파티션 구조를 조작하여 이러한 번거로운 작업을 거의
                    즉각적으로 실행할 수 있다는 것입니다.
                </para>

                <para> 오래된 데이터를 제거하는 가장 간단한 방법은 더 이상 필요하지 않은 파티션을 삭제하는 것입니다: <programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
                    이는 각 레코드를 개별적으로 삭제할 필요가 없기 때문에 수백만 개의 레코드를 매우 빠르게 삭제할 수 있습니다. 하지만 위의 명령은 부모 테이블에
                    대한 <literal>ACCESS EXCLUSIVE</literal> 잠금이 필요하다는 점에 주의하십시오. </para>

                <para> 종종 더 선호되는 다른 옵션은 파티션을 파티션된 테이블에서 제거하되 자체 권한으로 테이블로 접근할 수 있도록 유지하는 것입니다. 이에는 두
                    가지 형태가 있습니다: <programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02 CONCURRENTLY;
</programlisting> 이를 통해 데이터를 삭제하기 전에 추가 작업을 수행할 수
                    있습니다. 예를 들어, 이는 종종 <command>COPY</command>, <application>pg_dump</application>
                    또는 유사한 도구를 사용하여 데이터를 백업하기에 유용한 시기입니다. 또한 데이터를 더 작은 형식으로 집계하거나, 다른 데이터 조작을 수행하거나,
                    보고서를 실행하기에 유용한 시기일 수 있습니다. 명령의 첫 번째 형태는 부모 테이블에 대한 <literal>ACCESS EXCLUSIVE</literal>
                    잠금이 필요합니다. 두 번째 형태에서처럼 <literal>CONCURRENTLY</literal> 한정자를 추가하면 분리 작업에 부모 테이블에
                    대한 <literal>SHARE UPDATE EXCLUSIVE</literal> 잠금만 필요하지만, 제한 사항에 대해서는 <link
                        linkend="sql-altertable-detach-partition">
                        <literal>ALTER TABLE ... DETACH PARTITION</literal>
                    </link>을
                    참조하십시오. </para>

                <para> 비슷한 방식으로 새로운 데이터를 처리하기 위해 새 파티션을 추가할 수 있습니다. 위에서 생성한 원래 파티션과 같은 방식으로 파티션 테이블에
                    빈 파티션을 생성할 수 있습니다: <programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting> 새 파티션을 생성하는 대신, 때로는 파티션 구조와
                    별개로 새 테이블을 만들어 나중에 파티션으로 연결하는 것이 더 편리할 수 있습니다. 이렇게 하면 새 데이터가 파티션 테이블에 나타나기 전에
                    로드, 검사 및 변환할 수 있습니다. 또한, <literal>ATTACH PARTITION</literal> 작업은 <command>CREATE
                    TABLE ... PARTITION OF</command>에 필요한 <literal>ACCESS EXCLUSIVE</literal> 잠금 대신
                    파티션 테이블에 대해 <literal>SHARE UPDATE EXCLUSIVE</literal> 잠금만 필요로 하므로, 파티션 테이블의 동시
                    작업에 더 친화적입니다. 자세한 내용은 <link linkend="sql-altertable-attach-partition">
                        <literal>ALTER TABLE ... ATTACH PARTITION</literal>
                    </link>
                    을 참조하세요. 부모 테이블의 정의를 번거롭게 반복하지 않도록 <link linkend="sql-createtable-parms-like">
                        <literal>CREATE TABLE ... LIKE</literal>
                    </link> 옵션이 도움이
                    될 수 있습니다. 예를 들면: <programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 가능한 다른 데이터 준비 작업

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
                </para>

                <para>
                    <command>ATTACH PARTITION</command> 명령을 실행할 때, 해당 파티션에 대해 <literal>ACCESS
                    EXCLUSIVE</literal> 잠금을 유지하면서 파티션 제약조건을 검증하기 위해 테이블이 스캔된다는 점에 주의하세요. 위에서 보여진
                    것처럼, 테이블을 연결하기 전에 예상되는 파티션 제약조건과 일치하는 <literal>CHECK</literal> 제약조건을 생성하여 이 스캔을
                    피하는 것이 좋습니다. <command>ATTACH PARTITION</command>이 완료되면 이제 중복된 <literal>CHECK</literal>
                    제약조건을 삭제하는 것이 좋습니다. 연결되는 테이블이 자체적으로 파티션 테이블인 경우, 적절한 <literal>CHECK</literal>
                    제약조건을 만나거나 리프 파티션에 도달할 때까지 각 하위 파티션이 재귀적으로 잠기고 스캔됩니다. </para>

                <para> 마찬가지로, 파티션 테이블에 <literal>DEFAULT</literal> 파티션이 있는 경우, 연결될 파티션의 제약조건을 제외하는 <literal>
                    CHECK</literal> 제약조건을 만드는 것이 좋습니다. 이렇게 하지 않으면, <literal>DEFAULT</literal> 파티션이
                    연결되는 파티션에 위치해야 하는 레코드를 포함하고 있지 않은지 확인하기 위해 스캔됩니다. 이 작업은 <literal>DEFAULT</literal>
                    파티션에 대해 <literal>ACCESS EXCLUSIVE</literal> 잠금을 유지하면서 수행됩니다. <literal>DEFAULT</literal>
                    파티션이 자체적으로 파티션 테이블인 경우, 위에서 언급한 것처럼 연결되는 테이블과 동일한 방식으로 각 파티션이 재귀적으로 검사됩니다. </para>

                <para> 앞서 언급했듯이, 전체 계층 구조에 자동으로 적용되도록 파티션 테이블에 인덱스를 생성할 수 있습니다. 이는 기존의 모든 파티션에 인덱스가
                    적용될 뿐만 아니라 향후 파티션에도 적용되므로 매우 편리할 수 있습니다. 그러나 파티션 테이블에 새 인덱스를 생성할 때의 한 가지 제한사항은 <literal>
                    CONCURRENTLY</literal> 한정자를 사용할 수 없다는 것입니다. 이로 인해 긴 잠금 시간이 발생할 수 있습니다. 이를 피하기
                    위해, 파티션 테이블에 대해 <command>CREATE INDEX ON ONLY</command>를 사용할 수 있습니다. 이는 새 인덱스를
                    무효로 표시하여 기존 파티션에 자동 적용되는 것을 방지합니다. 대신, <literal>CONCURRENTLY</literal>를 사용하여 각
                    파티션에 개별적으로 인덱스를 생성하고 <command>ALTER INDEX ... ATTACH PARTITION</command>를 사용하여
                    부모의 파티션 인덱스에 <firstterm>연결</firstterm>할 수 있습니다. 모든 파티션의 인덱스가 부모 인덱스에 연결되면 부모
                    인덱스가 자동으로 유효하게 표시됩니다. 예시: <programlisting>
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);

CREATE INDEX CONCURRENTLY measurement_usls_200602_idx
    ON measurement_y2006m02 (unitsales);
ALTER INDEX measurement_usls_idx
    ATTACH PARTITION measurement_usls_200602_idx;
...
</programlisting> 이 기술은 <literal>
                    UNIQUE</literal>와 <literal>PRIMARY KEY</literal> 제약조건에도 사용할 수 있습니다; 제약조건이 생성될 때
                    인덱스가 암시적으로 생성됩니다. 예시: <programlisting>
ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);

ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);
ALTER INDEX measurement_city_id_logdate_key
    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;
...
</programlisting>
                </para>
            </sect3>

            <sect3 id="ddl-partitioning-declarative-limitations">
                <title>제한사항</title>

                <para> 파티션 테이블에는 다음과 같은 제한사항이 적용됩니다: <itemizedlist>
                        <listitem>
                            <para>
                                파티션 테이블에 고유 키나 기본 키 제약조건을 생성하려면, 파티션 키에
                                표현식이나 함수 호출이 포함되어서는 안 되며, 제약조건의 열에는 모든
                                파티션 키 열이 포함되어야 합니다. 이러한 제한은 제약조건을 구성하는
                                개별 인덱스가 자신의 파티션 내에서만 직접적으로 고유성을 강제할 수
                                있기 때문에 존재합니다. 따라서 파티션 구조 자체가 서로 다른 파티션에
                                중복이 없음을 보장해야 합니다.
                            </para>
                        </listitem>

                        <listitem>
                            <para> 마찬가지로 배제 제약조건은 모든 파티션 키 열을 포함해야 합니다. 또한 제약조건은 이러한 열들을 등호로 비교해야
                    합니다(예: <literal>&amp;&amp;</literal>가 아님). 이 제한 역시 파티션 간 제한사항을 강제할 수 없다는 점에서
                    비롯됩니다. 제약조건에는 파티션 키의 일부가 아닌 추가 열이 포함될 수 있으며, 이러한 열들은 원하는 연산자로 비교할 수 있습니다. </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>BEFORE ROW</literal> 트리거에서 <literal>INSERT</literal>는 새 행의
                    최종 목적지가 되는 파티션을 변경할 수 없습니다. </para>
                        </listitem>

                        <listitem>
                            <para>
                                동일한 파티션 트리에서 임시 관계와 영구 관계를 혼합하는 것은
                                허용되지 않습니다. 따라서 파티션 테이블이 영구적이면 그 파티션도
                                영구적이어야 하며, 마찬가지로 파티션 테이블이 임시적이면 그 파티션도
                                임시적이어야 합니다. 임시 관계를 사용할 때는 파티션 트리의 모든
                                멤버가 동일한 세션에서 와야 합니다.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>
                    개별 파티션은 상속을 사용하여 내부적으로 파티션 테이블에 연결됩니다.
                    그러나 아래에서 설명하는 것처럼 선언적 파티션 테이블이나 그 파티션에
                    상속의 일반적인 기능을 모두 사용할 수는 없습니다. 특히, 파티션은
                    자신이 속한 파티션 테이블 이외의 다른 부모를 가질 수 없으며,
                    테이블이 파티션 테이블과 일반 테이블 모두에서 상속받을 수도 없습니다.
                    이는 파티션 테이블과 그 파티션이 일반 테이블과 상속 계층을 공유하지
                    않는다는 것을 의미합니다.
                </para>

                <para> 파티션 테이블과 그 파티션으로 구성된 파티션 계층도 상속 계층이므로, <structfield>tableoid</structfield>와 <xref
                        linkend="ddl-inherit" />에서 설명된 모든 일반적인 상속 규칙이 적용됩니다. 다만 몇 가지 예외가 있습니다: <itemizedlist>
                        <listitem>
                            <para> 파티션은 부모에 없는 열을 가질 수 없습니다. <command>CREATE TABLE</command>로 파티션을
                    생성할 때 열을 지정할 수 없으며, <command>ALTER TABLE</command>을 사용하여 나중에 파티션에 열을 추가할 수도
                    없습니다. 테이블을 <command>ALTER TABLE ... ATTACH PARTITION</command>으로 파티션으로 추가할 때는 해당
                    테이블의 열이 부모와 정확히 일치하는 경우에만 가능합니다. </para>
                        </listitem>

                        <listitem>
                            <para> 파티션 테이블의 <literal>CHECK</literal>와 <literal>NOT NULL</literal>
                    제약조건은 항상 모든 파티션에 상속됩니다; 이러한 유형의 <literal>NO INHERIT</literal> 제약조건을 생성하는 것은 허용되지
                    않습니다. 동일한 제약조건이 부모 테이블에 있는 경우에는 해당 유형의 제약조건을 삭제할 수 없습니다. </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>ONLY</literal>를 사용하여 파티션 테이블에만 제약조건을 추가하거나 삭제하는 것은 파티션이 없는
                    경우에만 지원됩니다. 파티션이 존재하면 <literal>UNIQUE</literal>와 <literal>PRIMARY KEY</literal>
                    이외의 제약조건에 대해 <literal>ONLY</literal>를 사용하면 오류가 발생합니다. 대신, 파티션 자체에 제약조건을 추가하고 (부모
                    테이블에 없는 경우) 삭제할 수 있습니다. </para>
                        </listitem>

                        <listitem>
                            <para> 파티션 테이블은 자체적으로 데이터를 가지지 않으므로, 파티션 테이블에 대해 <command>TRUNCATE</command> <literal>
                    ONLY</literal>를 사용하려는 시도는 항상 오류를 반환합니다. </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect3>
        </sect2>

        <sect2 id="ddl-partitioning-using-inheritance">
            <title>상속을 사용한 파티셔닝</title>

            <para> 내장된 선언적 파티셔닝이 대부분의 일반적인 사용 사례에 적합하지만, 더 유연한 접근 방식이 유용할 수 있는 상황이 있습니다. 파티셔닝은 테이블
                상속을 사용하여 구현할 수 있으며, 이는 선언적 파티셔닝에서 지원하지 않는 여러 기능을 제공합니다: <itemizedlist>
                    <listitem>
                        <para>
                            선언적 파티셔닝의 경우 파티션은 파티션 테이블과 정확히 동일한 열 집합을
                            가져야 하지만, 테이블 상속의 경우 자식 테이블은 부모에 없는 추가 열을
                            가질 수 있습니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            테이블 상속은 다중 상속을 허용합니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            선언적 파티셔닝은 범위, 리스트, 해시 파티셔닝만 지원하는 반면,
                            테이블 상속은 사용자가 선택한 방식으로 데이터를 분할할 수 있습니다.
                            (단, 제약 조건 제외가 자식 테이블을 효과적으로 제거하지 못하는 경우
                            쿼리 성능이 저하될 수 있습니다.)
                        </para>
                    </listitem>
                </itemizedlist>
            </para>

            <sect3 id="ddl-partitioning-inheritance-example">
                <title>예시</title>

                <para> 이 예시는 위의 선언적 파티셔닝 예시와 동등한 파티셔닝 구조를 구축합니다. 다음 단계를 따르세요: <orderedlist
                        spacing="compact">
                        <listitem>
                            <para> 모든 <quote>자식</quote> 테이블이 상속할 <quote>루트</quote> 테이블을 생성합니다. 이
                    테이블에는 데이터가 포함되지 않습니다. 모든 자식 테이블에 동일하게 적용하려는 경우가 아니라면 이 테이블에 체크 제약조건을 정의하지 마세요.
                    인덱스나 고유 제약조건을 정의하는 것도 의미가 없습니다. 우리의 예시에서 루트 테이블은 원래 정의된 <structname>measurement</structname>
                    테이블입니다: <programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para> 루트 테이블에서 상속하는 여러 <quote>자식</quote> 테이블을 생성합니다. 일반적으로 이러한 테이블은
                    루트에서 상속받은 열 집합에 열을 추가하지 않습니다. 선언적 파티셔닝과 마찬가지로, 이러한 테이블은 모든 면에서 일반적인 <productname>
                    PostgreSQL</productname> 테이블(또는 외부 테이블)입니다. </para>

                            <para>
                                <programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                각 자식 테이블에 겹치지 않는 테이블 제약조건을 추가하여
                                각각에서 허용되는 키 값을 정의합니다.
                            </para>

                            <para> 일반적인 예는 다음과 같습니다: <programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting> 제약조건이 서로 다른
                    자식 테이블에서 허용되는 키 값 사이에 겹침이 없도록 보장하세요. 다음과 같은 범위 제약조건을 설정하는 것은 일반적인 실수입니다: <programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
                    이는 키 값 200이 어느 자식 테이블에 속하는지 명확하지 않기 때문에 잘못된 것입니다. 대신 범위는 다음과 같은 스타일로 정의해야 합니다: <programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para> 각 자식 테이블에 대해 키 열에 인덱스를 생성하고, 필요한 다른 인덱스도 생성합니다. <programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
                            </para>
                        </listitem>

                        <listitem>
                            <para> 우리의 애플리케이션이 <literal>INSERT INTO measurement ...</literal>를 실행하고
                    데이터가 적절한 자식 테이블로 리디렉션되기를 원합니다. 이는 루트 테이블에 적절한 트리거 함수를 연결하여 구성할 수 있습니다. 데이터가 최신
                    자식에만 추가될 경우 매우 간단한 트리거 함수를 사용할 수 있습니다: <programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
                            </para>

                            <para> 함수를 생성한 후, 트리거 함수를 호출하는 트리거를 생성합니다: <programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>
                    현재 자식 테이블에 항상 삽입되도록 매월 트리거 함수를 재정의해야 합니다. 하지만 트리거 정의는 업데이트할 필요가 없습니다. </para>

                            <para> 데이터를 삽입할 때 서버가 자동으로 행이 추가되어야 할 자식 테이블을 찾도록 할 수 있습니다. 이는 더 복잡한 트리거
                    함수를 사용하여 수행할 수 있습니다. 예를 들면: <programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting> 트리거 정의는 이전과 동일합니다.
                    각 <literal>IF</literal> 테스트는 해당 자식 테이블의 <literal>CHECK</literal> 제약조건과 정확히 일치해야
                    합니다. </para>

                            <para>
                                이 함수는 단일 월 케이스보다 더 복잡하지만, 필요한 분기를 미리
                                추가할 수 있기 때문에 자주 업데이트할 필요가 없습니다.
                            </para>

                            <note>
                                <para>
                                    실제로는 대부분의 삽입이 최신 자식에 이루어지는 경우, 최신 자식을
                                    먼저 확인하는 것이 가장 좋을 수 있습니다. 단순화를 위해, 우리는
                                    이 예제의 다른 부분과 동일한 순서로 트리거의 테스트를 보여주었습니다.
                                </para>
                            </note>

                            <para> 적절한 자식 테이블로 삽입을 리디렉션하는 다른 접근 방식은 루트 테이블에 트리거 대신 규칙을 설정하는 것입니다. 예를
                    들면: <programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting> 규칙은 트리거보다 상당히 더 많은 오버헤드를 가지지만, 오버헤드는 행당 한
                    번이 아닌 쿼리당 한 번 발생하므로 대량 삽입 상황에서는 이 방법이 유리할 수 있습니다. 하지만 대부분의 경우 트리거 방식이 더 나은 성능을
                    제공할 것입니다. </para>

                            <para>
                                <command>COPY</command>는 규칙을 무시한다는 점에 주의하세요. <command>COPY</command>를
                    사용하여 데이터를 삽입하려면 루트에 직접 복사하는 대신 올바른 자식 테이블에 복사해야 합니다. <command>COPY</command>는
                    트리거를 실행하므로 트리거 방식을 사용하는 경우 정상적으로 사용할 수 있습니다. </para>

                            <para>
                                규칙 접근 방식의 또 다른 단점은 규칙 집합이 삽입 날짜를 커버하지
                                않는 경우 오류를 강제하는 간단한 방법이 없다는 것입니다;
                                데이터는 대신 루트 테이블로 조용히 들어갈 것입니다.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <filename>postgresql.conf</filename>에서 <xref
                                    linkend="guc-constraint-exclusion" /> 설정 매개변수가 비활성화되어 있지 않은지
                    확인하세요; 그렇지 않으면 자식 테이블이 불필요하게 접근될 수 있습니다. </para>
                        </listitem>
                    </orderedlist>
                </para>

                <para>
                    보다시피, 복잡한 테이블 계층은 상당한 양의 DDL이 필요할 수 있습니다.
                    위의 예에서는 매월 새로운 자식 테이블을 생성하므로, 필요한 DDL을
                    자동으로 생성하는 스크립트를 작성하는 것이 현명할 수 있습니다.
                </para>
            </sect3>

            <sect3 id="ddl-partitioning-inheritance-maintenance">
                <title>상속 파티셔닝의 유지보수</title>
                <para> 오래된 데이터를 빠르게 제거하려면 더 이상 필요하지 않은 자식 테이블을 간단히 삭제하면 됩니다: <programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
                </para>

                <para> 자식 테이블을 상속 계층에서 제거하되 독립적인 테이블로 접근을 유지하려면: <programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
                </para>

                <para> 새로운 데이터를 처리하기 위해 새 자식 테이블을 추가하려면, 위에서 원래 자식들이 생성된 것처럼 빈 자식 테이블을 생성합니다: <programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>
                    또는, 테이블 계층에 추가하기 전에 새 자식 테이블을 생성하고 채우고 싶을 수 있습니다. 이렇게 하면 부모 테이블의 쿼리에 표시되기 전에
                    데이터를 로드, 검사 및 변환할 수 있습니다. <programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 가능한 다른 데이터 준비 작업
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
                </para>
            </sect3>

            <sect3 id="ddl-partitioning-inheritance-caveats">
                <title>주의사항</title>

                <para> 상속을 사용하여 구현된 파티셔닝에는 다음과 같은 주의사항이 적용됩니다: <itemizedlist>
                        <listitem>
                            <para> 모든 <literal>CHECK</literal> 제약조건이 상호 배타적인지 자동으로 확인하는 방법은 없습니다.
                    각각을 수동으로 작성하는 것보다 자식 테이블을 생성하고 관련 객체를 생성 및/또는 수정하는 코드를 작성하는 것이 더 안전합니다. </para>
                        </listitem>

                        <listitem>
                            <para> 인덱스와 외래 키 제약조건은 단일 테이블에만 적용되고 상속된 자식에는 적용되지 않으므로, 알아야 할 몇 가지 <link
                                    linkend="ddl-inherit-caveats">주의사항</link>이 있습니다. </para>
                        </listitem>

                        <listitem>
                            <para> 여기서 보여진 스키마들은 행의 키 열 값이 절대 변경되지 않거나, 최소한 다른 파티션으로 이동해야 할 정도로 변경되지
                    않는다고 가정합니다. 이를 시도하는 <command>UPDATE</command>는 <literal>CHECK</literal> 제약조건으로
                    인해 실패할 것입니다. 이러한 경우를 처리해야 한다면 자식 테이블에 적절한 업데이트 트리거를 둘 수 있지만, 이는 구조의 관리를 훨씬 더
                    복잡하게 만듭니다. </para>
                        </listitem>

                        <listitem>
                            <para> 수동 <command>VACUUM</command>과 <command>ANALYZE</command> 명령은 자동으로
                    모든 상속된 자식 테이블을 처리합니다. 이것이 바람직하지 않은 경우, <literal>ONLY</literal> 키워드를 사용할 수 있습니다.
                    다음과 같은 명령: <programlisting>
ANALYZE ONLY measurement;
</programlisting> 은 루트 테이블만 처리할 것입니다. </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>ON CONFLICT</literal> 절이 있는 <command>INSERT</command> 문은
                    예상대로 작동하지 않을 가능성이 높습니다. <literal>ON CONFLICT</literal> 동작은 지정된 대상 관계에서의 고유성 위반에만
                    적용되고 자식 관계에는 적용되지 않기 때문입니다. </para>
                        </listitem>

                        <listitem>
                            <para>
                                애플리케이션이 파티셔닝 스키마를 명시적으로 인식하지 않는 한,
                                행을 원하는 자식 테이블로 라우팅하기 위해 트리거나 규칙이 필요합니다.
                                트리거는 작성하기 복잡할 수 있으며, 선언적 파티셔닝에서 내부적으로
                                수행되는 튜플 라우팅보다 훨씬 느릴 것입니다.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect3>
        </sect2>

        <sect2 id="ddl-partition-pruning">
            <title>파티션 가지치기</title>

            <indexterm>
                <primary>partition pruning</primary>
            </indexterm>

            <para>
                <firstterm>파티션 가지치기</firstterm>는 선언적 파티션 테이블의 성능을 향상시키는 쿼리 최적화 기술입니다. 예를 들면: <programlisting>
SET enable_partition_pruning = on;                 -- 기본값
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>
                파티션 가지치기가 없다면, 위의 쿼리는 <structname>measurement</structname> 테이블의 각 파티션을 스캔할 것입니다. 파티션
                가지치기가 활성화되면, 플래너는 각 파티션의 정의를 검사하고 쿼리의 <literal>WHERE</literal> 절을 만족하는 행을 포함할 수 없다는
                것을 증명할 수 있는 경우 해당 파티션을 스캔할 필요가 없다는 것을 증명합니다. 플래너가 이를 증명할 수 있을 때, 쿼리 계획에서 파티션을 제외(<firstterm>
                가지치기</firstterm>)합니다. </para>

            <para> EXPLAIN 명령과 <xref linkend="guc-enable-partition-pruning" /> 설정 매개변수를 사용하여, 파티션이
                가지치기된 계획과 그렇지 않은 계획의 차이를 보여줄 수 있습니다. 이러한 유형의 테이블 설정에 대한 일반적인 최적화되지 않은 계획은 다음과 같습니다: <programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
                일부 또는 모든 파티션이 전체 테이블 순차 스캔 대신 인덱스 스캔을 사용할 수 있지만, 여기서 중요한 점은 이 쿼리에 답하기 위해 오래된 파티션을 전혀
                스캔할 필요가 없다는 것입니다. 파티션 가지치기를 활성화하면, 동일한 답을 제공하는 훨씬 저렴한 계획을 얻습니다: <programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
         Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
            </para>

            <para>
                파티션 가지치기는 인덱스의 존재가 아닌 파티션 키에 의해 암시적으로
                정의된 제약조건에 의해서만 수행됩니다. 따라서 키 열에 인덱스를 정의할
                필요는 없습니다. 주어진 파티션에 대해 인덱스를 생성할 필요가 있는지는
                파티션을 스캔하는 쿼리가 일반적으로 파티션의 큰 부분을 스캔할지
                작은 부분을 스캔할지에 따라 달라집니다. 후자의 경우에는 인덱스가
                도움이 되지만 전자의 경우에는 그렇지 않습니다.
            </para>

            <para> 파티션 가지치기는 주어진 쿼리의 계획 수립 시점뿐만 아니라 실행 중에도 수행될 수 있습니다. 이는 쿼리 계획 시점에 값을 알 수 없는 표현식이
                포함된 절이 있을 때 더 많은 파티션을 가지칠 수 있게 해주므로 유용합니다. 예를 들어, <command>PREPARE</command> 문에 정의된
                매개변수, 서브쿼리에서 얻은 값, 또는 중첩 루프 조인의 내부에서 매개변수화된 값을 사용하는 경우입니다. 실행 중 파티션 가지치기는 다음 시점에 수행될
                수 있습니다: <itemizedlist>
                    <listitem>
                        <para> 쿼리 계획 초기화 중. 실행의 초기화 단계에서 알 수 있는 매개변수 값에 대해 파티션 가지치기를 수행할 수 있습니다. 이
                단계에서 가지치기된 파티션은 쿼리의 <command>EXPLAIN</command> 또는 <command>EXPLAIN ANALYZE</command>에
                나타나지 않습니다. <command>EXPLAIN</command> 출력의 <quote>Subplans Removed</quote> 속성을 관찰하여 이
                단계에서 제거된 파티션의 수를 확인할 수 있습니다. </para>
                    </listitem>

                    <listitem>
                        <para> 쿼리 계획의 실제 실행 중. 실제 쿼리 실행 중에만 알 수 있는 값을 사용하여 파티션을 제거하기 위해 이 시점에서도 파티션
                가지치기를 수행할 수 있습니다. 여기에는 서브쿼리의 값과 매개변수화된 중첩 루프 조인과 같은 실행 시간 매개변수의 값이 포함됩니다. 이러한 매개변수의
                값이 쿼리 실행 중에 여러 번 변경될 수 있으므로, 파티션 가지치기에 사용되는 실행 매개변수 중 하나가 변경될 때마다 파티션 가지치기가 수행됩니다. 이
                단계에서 파티션이 가지치기되었는지 확인하려면 <command>EXPLAIN ANALYZE</command> 출력의 <literal>loops</literal>
                속성을 주의 깊게 검사해야 합니다. 서로 다른 파티션에 해당하는 하위 계획은 실행 중에 각각이 가지치기된 횟수에 따라 다른 값을 가질 수 있습니다.
                일부는 매번 가지치기된 경우 <literal>(never executed)</literal>로 표시될 수 있습니다. </para>
                    </listitem>
                </itemizedlist>
            </para>

            <para> 파티션 가지치기는 <xref linkend="guc-enable-partition-pruning" /> 설정을 사용하여 비활성화할 수 있습니다. </para>
        </sect2>

        <sect2 id="ddl-partitioning-constraint-exclusion">
            <title>파티셔닝과 제약조건 제외</title>

            <indexterm>
                <primary>constraint exclusion</primary>
            </indexterm>

            <para>
                <firstterm>제약조건 제외</firstterm>는 파티션 가지치기와 유사한 쿼리 최적화 기술입니다. 주로 레거시 상속 방식을 사용하여 구현된
                파티셔닝에 사용되지만, 선언적 파티셔닝을 포함한 다른 목적으로도 사용될 수 있습니다. </para>

            <para> 제약조건 제외는 파티션 가지치기와 매우 유사한 방식으로 작동하지만, 선언적 파티셔닝의 경우에만 존재하는 테이블의 파티션 경계를 사용하는 파티션
                가지치기와 달리 각 테이블의 <literal>CHECK</literal> 제약조건을 사용합니다 &mdash; 이것이 이름의 유래입니다. 또 다른
                차이점은 제약조건 제외가 계획 시점에만 적용된다는 것입니다; 실행 시점에는 파티션을 제거하려는 시도가 없습니다. </para>

            <para> 제약조건 제외가 <literal>CHECK</literal> 제약조건을 사용한다는 사실은 파티션 가지치기에 비해 느리지만, 때로는 장점으로 사용될
                수 있습니다: 제약조건은 내부 파티션 경계 외에도 선언적 파티션 테이블에도 정의될 수 있기 때문에, 제약조건 제외는 쿼리 계획에서 추가 파티션을 제거할
                수 있습니다. </para>

            <para>
                <xref linkend="guc-constraint-exclusion" />의 기본(그리고 권장) 설정은 <literal>on</literal>도 <literal>
                off</literal>도 아닌 <literal>partition</literal>이라는 중간 설정입니다. 이는 상속 파티션 테이블에서 작동할 가능성이
                있는 쿼리에만 이 기술을 적용하도록 합니다. <literal>on</literal> 설정은 이점을 얻을 가능성이 낮은 단순한 쿼리를 포함한 모든
                쿼리에서 플래너가 <literal>CHECK</literal> 제약조건을 검사하도록 합니다. </para>

            <para> 제약조건 제외에는 다음과 같은 주의사항이 적용됩니다: <itemizedlist>
                    <listitem>
                        <para>
                            제약조건 제외는 쿼리 실행 중에도 적용될 수 있는 파티션 가지치기와
                            달리 쿼리 계획 수립 중에만 적용됩니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para> 제약조건 제외는 쿼리의 <literal>WHERE</literal> 절에 상수(또는 외부에서 제공된 매개변수)가 포함된
                경우에만 작동합니다. 예를 들어, <function>CURRENT_TIMESTAMP</function>와 같은 비불변 함수와의 비교는 최적화될 수
                없습니다. 플래너는 실행 시점에 함수의 값이 어느 자식 테이블에 속할지 알 수 없기 때문입니다. </para>
                    </listitem>

                    <listitem>
                        <para>
                            파티셔닝 제약조건을 단순하게 유지하세요. 그렇지 않으면 플래너가
                            자식 테이블을 방문할 필요가 없다는 것을 증명하지 못할 수 있습니다.
                            앞의 예제에서 보여진 것처럼 리스트 파티셔닝에는 단순한 등식 조건을,
                            범위 파티셔닝에는 단순한 범위 테스트를 사용하세요. 좋은 경험칙은
                            파티셔닝 제약조건이 B-트리 인덱스 가능한 연산자를 사용하여
                            파티션 열을 상수와 비교하는 것만 포함해야 한다는 것입니다.
                            파티션 키에는 B-트리 인덱스 가능한 열만 허용되기 때문입니다.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            제약조건 제외 중에는 부모 테이블의 모든 자식에 대한 모든 제약조건이
                            검사되므로, 자식이 많으면 쿼리 계획 시간이 상당히 증가할 가능성이
                            높습니다. 따라서 레거시 상속 기반 파티셔닝은 아마도 100개 정도의
                            자식 테이블까지는 잘 작동할 것입니다; 수천 개의 자식을 사용하려고
                            하지 마세요.
                        </para>
                    </listitem>

                </itemizedlist>
            </para>
        </sect2>

        <sect2 id="ddl-partitioning-declarative-best-practices">
            <title>선언적 파티셔닝의 모범 사례</title>

            <para>
                쿼리 계획과 실행의 성능이 잘못된 설계로 인해 부정적인 영향을 받을 수
                있으므로 테이블을 파티션하는 방법을 신중하게 선택해야 합니다.
            </para>

            <para> 가장 중요한 설계 결정 중 하나는 데이터를 파티션할 열 또는 열들의 선택입니다. 종종 가장 좋은 선택은 파티션된 테이블에서 실행되는 쿼리의 <literal>
                WHERE</literal> 절에 가장 자주 나타나는 열 또는 열의 집합으로 파티션하는 것입니다. 파티션 경계 제약조건과 호환되는 <literal>
                WHERE</literal> 절은 불필요한 파티션을 가지치기하는 데 사용될 수 있습니다. 하지만 <literal>PRIMARY KEY</literal>
                나 
    <literal>UNIQUE</literal> 제약조건에 대한 요구사항으로 인해 다른 결정을 해야 할 수도 있습니다. 원하지 않는 데이터의
                제거도 파티셔닝 전략을 계획할 때 고려해야 할 요소입니다. 전체 파티션을 꽤 빠르게 분리할 수 있으므로, 한 번에 제거할 모든 데이터가 단일 파티션에
                위치하도록 파티션 전략을 설계하는 것이 유리할 수 있습니다. </para>

            <para> 테이블을 나눌 대상 파티션 수를 선택하는 것도 중요한 결정입니다. 파티션이 충분하지 않으면 인덱스가 너무 크게 유지되고 데이터 지역성이 낮게
                유지되어 캐시 적중률이 낮아질 수 있습니다. 그러나 테이블을 너무 많은 파티션으로 나누는 것도 문제를 일으킬 수 있습니다. 아래에서 자세히 설명하는
                것처럼, 너무 많은 파티션은 더 긴 쿼리 계획 시간과 쿼리 계획 및 실행 중 더 높은 메모리 소비를 의미할 수 있습니다. 테이블을 파티션하는 방법을
                선택할 때, 미래에 발생할 수 있는 변화도 고려하는 것이 중요합니다. 예를 들어, 현재 소수의 대형 고객을 보유하고 있고 고객당 하나의 파티션을 갖기로
                선택한 경우, 수년 후에 다수의 소형 고객을 보유하게 되는 상황의 영향을 고려해보세요. 이 경우, <literal>LIST</literal>로
                파티션하고 고객 수가 실용적으로 데이터를 파티션할 수 있는 수준을 넘지 않기를 바라는 것보다 <literal>HASH</literal>로 파티션하고
                적절한 수의 파티션을 선택하는 것이 더 나을 수 있습니다. </para>

            <para>
                하위 파티셔닝은 다른 파티션보다 더 커질 것으로 예상되는 파티션을
                더 세분화하는 데 유용할 수 있습니다. 다른 옵션은 파티션 키에 여러 열을
                사용하여 범위 파티셔닝을 하는 것입니다. 이 두 가지 모두 쉽게 과도한
                수의 파티션으로 이어질 수 있으므로, 절제가 필요합니다.
            </para>

            <para>
                쿼리 계획 및 실행 중의 파티셔닝 오버헤드를 고려하는 것이 중요합니다.
                일반적으로 쿼리 플래너는 일반적인 쿼리가 소수의 파티션만 남기고
                모두 가지치기할 수 있다면 최대 몇 천 개의 파티션으로 구성된 파티션
                계층을 꽤 잘 처리할 수 있습니다. 플래너가 파티션 가지치기를 수행한
                후 더 많은 파티션이 남아있으면 계획 시간이 길어지고 메모리 소비가
                높아집니다. 많은 수의 파티션을 우려해야 하는 또 다른 이유는
                특히 많은 세션이 많은 수의 파티션을 다루는 경우 서버의 메모리 소비가
                시간이 지남에 따라 크게 증가할 수 있다는 것입니다. 이는 각 파티션이
                그것을 다루는 각 세션의 로컬 메모리에 메타데이터를 로드해야 하기
                때문입니다.
            </para>

            <para> 데이터 웨어하우스 유형의 워크로드에서는 <acronym>OLTP</acronym> 유형의 워크로드보다 더 많은 수의 파티션을 사용하는 것이
                합리적일 수 있습니다. 일반적으로 데이터 웨어하우스에서는 처리 시간의 대부분이 쿼리 실행 중에 소비되므로 쿼리 계획 시간이 덜 중요합니다. 이 두
                유형의 워크로드 모두에서 초기에 올바른 결정을 내리는 것이 중요합니다. 대량의 데이터를 재파티셔닝하는 것은 매우 느릴 수 있기 때문입니다. 의도된
                워크로드를 시뮬레이션하는 것이 파티셔닝 전략을 최적화하는 데 종종 도움이 됩니다. 더 많은 파티션이 더 적은 파티션보다 낫다거나 그 반대라고 절대
                가정하지 마세요. </para>
        </sect2>

    </sect1>

    <sect1 id="ddl-foreign-data">
        <title>외부 데이터</title>

        <indexterm>
            <primary>foreign data</primary>
        </indexterm>
        <indexterm>
            <primary>foreign table</primary>
        </indexterm>
        <indexterm>
            <primary>user mapping</primary>
        </indexterm>

        <para>
            <productname>PostgreSQL</productname>은 SQL/MED 사양의 일부를 구현하여, 일반 SQL 쿼리를 사용하여 PostgreSQL
            외부에 있는 데이터에 접근할 수 있게 합니다. 이러한 데이터를 <firstterm>외부 데이터</firstterm>라고 합니다. (이 용어는 데이터베이스 내의
            제약조건 유형인 외래 키와 혼동하지 않도록 주의하세요.) </para>

        <para> 외부 데이터는 <firstterm>외부 데이터 래퍼</firstterm>의 도움으로 접근됩니다. 외부 데이터 래퍼는 외부 데이터 소스와 통신할 수 있는
            라이브러리로, 데이터 소스에 연결하고 데이터를 얻는 세부사항을 숨깁니다. <filename>contrib</filename> 모듈로 사용할 수 있는 외부
            데이터 래퍼가 있습니다; <xref linkend="contrib" />를 참조하세요. 다른 종류의 외부 데이터 래퍼는 타사 제품으로 찾을 수 있습니다. 기존
            외부 데이터 래퍼가 요구사항에 맞지 않는 경우 직접 작성할 수 있습니다; <xref linkend="fdwhandler" />를 참조하세요. </para>

        <para> 외부 데이터에 접근하려면 <firstterm>외부 서버</firstterm> 객체를 생성해야 합니다. 이는 지원하는 외부 데이터 래퍼가 사용하는 옵션
            집합에 따라 특정 외부 데이터 소스에 연결하는 방법을 정의합니다. 그런 다음 하나 이상의 <firstterm>외부 테이블</firstterm>을 만들어야
            합니다. 이는 원격 데이터의 구조를 정의합니다. 외부 테이블은 일반 테이블처럼 쿼리에서 사용할 수 있지만, 외부 테이블은 PostgreSQL 서버에 저장소가
            없습니다. 사용될 때마다 <productname>PostgreSQL</productname>은 외부 데이터 래퍼에게 외부 소스에서 데이터를 가져오거나,
            업데이트 명령의 경우 외부 소스로 데이터를 전송하도록 요청합니다. </para>

        <para> 원격 데이터에 접근하려면 외부 데이터 소스에 대한 인증이 필요할 수 있습니다. 이 정보는 <firstterm>사용자 매핑</firstterm>에서 제공할
            수 있으며, 이는 현재 <productname>PostgreSQL</productname> 역할을 기반으로 사용자 이름과 비밀번호와 같은 추가 데이터를 제공할
            수 있습니다. </para>

        <para> 추가 정보는 다음을 참조하세요: <xref linkend="sql-createforeigndatawrapper" />, <xref
                linkend="sql-createserver" />, <xref linkend="sql-createusermapping" />, <xref
                linkend="sql-createforeigntable" />, 그리고 <xref linkend="sql-importforeignschema" />. </para>
    </sect1>

    <sect1 id="ddl-others">
        <title>기타 데이터베이스 객체</title>

        <para>
            테이블은 데이터를 보관하기 때문에 관계형 데이터베이스 구조의 중심
            객체입니다. 하지만 데이터베이스에 존재하는 유일한 객체는 아닙니다.
            데이터의 사용과 관리를 더 효율적이거나 편리하게 만들기 위해 다양한
            종류의 객체를 생성할 수 있습니다. 이 장에서는 이들을 논의하지 않지만,
            어떤 것들이 가능한지 알 수 있도록 목록을 제공합니다:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    뷰
                </para>
            </listitem>

            <listitem>
                <para>
                    함수, 프로시저, 연산자
                </para>
            </listitem>

            <listitem>
                <para>
                    데이터 타입과 도메인
                </para>
            </listitem>

            <listitem>
                <para>
                    트리거와 재작성 규칙
                </para>
            </listitem>
        </itemizedlist>

        <para> 이러한 주제에 대한 자세한 정보는 <xref linkend="server-programming" />에 나와 있습니다. </para>
    </sect1>

    <sect1 id="ddl-depend">
        <title>의존성 추적</title>

        <indexterm zone="ddl-depend">
            <primary>CASCADE</primary>
            <secondary sortas="DROP">with DROP</secondary>
        </indexterm>

        <indexterm zone="ddl-depend">
            <primary>RESTRICT</primary>
            <secondary sortas="DROP">with DROP</secondary>
        </indexterm>

        <para>
            외래 키 제약조건, 뷰, 트리거, 함수 등을 포함하는 많은 테이블이 있는
            복잡한 데이터베이스 구조를 만들 때, 객체 간의 의존성 네트워크를
            암시적으로 생성합니다. 예를 들어, 외래 키 제약조건이 있는 테이블은
            참조하는 테이블에 의존합니다.
        </para>

        <para> 전체 데이터베이스 구조의 무결성을 보장하기 위해, <productname>PostgreSQL</productname>은 다른 객체가 여전히 의존하고 있는
            객체를 삭제할 수 없도록 합니다. 예를 들어, <xref linkend="ddl-constraints-fk" />에서 고려했던 products 테이블을,
            orders 테이블이 의존하고 있는 상태에서 삭제하려고 하면 다음과 같은 오류 메시지가 발생합니다: <screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen> 오류 메시지에는 유용한
            힌트가 포함되어 있습니다: 의존하는 객체를 개별적으로 삭제하는 번거로움을 피하고 싶다면 다음을 실행할 수 있습니다: <screen>
DROP TABLE products CASCADE;
</screen> 그러면
            의존하는 모든 객체가 제거되며, 그들에 의존하는 객체들도 재귀적으로 제거됩니다. 이 경우, orders 테이블은 제거하지 않고 외래 키 제약조건만 제거합니다.
            외래 키 제약조건에 의존하는 것이 없기 때문에 거기서 멈춥니다. (<command>DROP ... CASCADE</command>가 무엇을 할지 확인하려면, <command>
            DROP</command>을 <literal>CASCADE</literal> 없이 실행하고 <literal>DETAIL</literal> 출력을 읽으세요.) </para>

        <para>
            <productname>PostgreSQL</productname>의 거의 모든 <command>DROP</command> 명령은 <literal>
            CASCADE</literal> 지정을 지원합니다. 물론 가능한 의존성의 특성은 객체의 유형에 따라 다릅니다. <literal>CASCADE</literal>
            대신 <literal>RESTRICT</literal>를 작성하여 다른 객체가 의존하는 객체의 삭제를 방지하는 기본 동작을 얻을 수도 있습니다. </para>

        <note>
            <para> SQL 표준에 따르면 <command>DROP</command> 명령에서 <literal>RESTRICT</literal> 또는 <literal>
                CASCADE</literal>를 지정하는 것이 필수입니다. 실제로 이 규칙을 강제하는 데이터베이스 시스템은 없지만, 기본 동작이 <literal>
                RESTRICT</literal>인지 <literal>CASCADE</literal>인지는 시스템마다 다릅니다. </para>
        </note>

        <para>
            <command>DROP</command> 명령이 여러 객체를 나열하는 경우, <literal>CASCADE</literal>는 지정된 그룹 외부에 의존성이
            있을 때만 필요합니다. 예를 들어, <literal>DROP TABLE tab1, tab2</literal>를 실행할 때 <literal>tab2</literal>
            에서 <literal>tab1</literal>을 참조하는 외래 키가 있다고 해서 성공하기 위해 <literal>CASCADE</literal>가 필요하다는
            의미는 아닙니다. </para>

        <para> 문자열 리터럴로 정의된 본문을 가진 사용자 정의 함수나 프로시저의 경우, <productname>PostgreSQL</productname>은 함수의
            외부적으로 보이는 속성 (인수 및 결과 타입 등)과 관련된 의존성은 추적하지만, 함수 본문을 검사해야만 알 수 있는 의존성은 추적하지 <emphasis>
            않습니다</emphasis>. 예를 들어, 다음과 같은 상황을 고려해보세요: <programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                            'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
 'SELECT note FROM my_colors WHERE color = $1'
 LANGUAGE SQL;
</programlisting> (SQL 언어 함수에
            대한 설명은 <xref linkend="xfunc-sql" />를 참조하세요.) <productname>PostgreSQL</productname>은 <function>
            get_color_note</function> 함수가 <type>rainbow</type> 타입에 의존한다는 것을 인식합니다: 타입을 삭제하면 인수 타입이 더
            이상 정의되지 않으므로 함수도 삭제해야 합니다. 하지만 <productname>PostgreSQL</productname>은 <function>
            get_color_note</function>가 <structname>my_colors</structname> 테이블에 의존한다고 간주하지 않으므로, 테이블이
            삭제되어도 함수를 삭제하지 않습니다. 이 접근 방식에는 단점도 있지만 장점도 있습니다. 테이블이 없더라도 함수는 어떤 의미에서는 여전히 유효하며, 실행하면
            오류가 발생하겠지만 동일한 이름의 새 테이블을 만들면 함수가 다시 작동할 수 있습니다. </para>

        <para> 반면에, SQL 표준 스타일로 작성된 본문을 가진 SQL 언어 함수나 프로시저의 경우, 본문은 함수 정의 시점에 파싱되며 파서가 인식한 모든 의존성이
            저장됩니다. 따라서 위의 함수를 다음과 같이 작성하면 <programlisting>
CREATE FUNCTION get_color_note (rainbow) RETURNS text
BEGIN ATOMIC
 SELECT note FROM my_colors WHERE color = $1;
END;
</programlisting> 함수의 <structname>
            my_colors</structname> 테이블에 대한 의존성이 알려지고 <command>DROP</command>에 의해 강제됩니다. </para>
    </sect1>

</chapter>